<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kaichao Sun"><meta name=description content="kaichao's blog"><meta name=generator content="Hugo 0.62.2"><title>Substrate 区块链应用的交易费用设计</title><link rel="shortcut icon" href=https://kaichaosun.github.io/images/favicon.ico><link rel=stylesheet href=https://kaichaosun.github.io/css/style.css><link rel=stylesheet href=https://kaichaosun.github.io/css/highlight.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css><meta property="og:title" content="Substrate 区块链应用的交易费用设计"><meta property="og:description" content="[TOC]
通过本文，你将学到：
 区块链应用为什么存在交易费用 Substrate 交易费用的组成 如何设计更合理的交易费用  为什么存在交易费用 在传统物联网（web 2.0）时代，使用微信、微博、淘宝等互联网应用时，终端用户不需要直接费用，而是由服务提供方利用用户的个人信息、产生的数据、注意力等来变现，典型的方式有
 广告推送； 通过用户数据分析指导商家决策； 甚至直接共享、贩卖用户隐私等。  在使用以上所说的web 2.0服务时，用户数据的所有者是服务提供方。在过去的20年里，虽然我们享受了互联网应用带来的好处，但也时刻“品尝”着隐私泄露、数据主权丢失带来的恶果。
区块链应用将服务的各个组件完全透明化，用户数据的所有权归属于个人，而不是应用的开发者或者任何其他的第三方。用户通过持有私钥掌握着数据，只有持有私钥的人才可以解锁和转移数据，敏感数据往往可以通过加密防止被窃取。
任何区块链应用的出现和流行都离不开这些利益相关方：
 开发和运营团队 维护网络正常运行的节点 终端用户  “天下没有免费的晚餐”，终端用户在享受自由的应用服务同时，需要支付相应的服务费用，也就是交易费用，因为服务是由交易触发的。这些费用可以用来激励相关方更加有效的协作，从而提供更优质的服务。
交易费用的另一个目的是在网络和计算资源有限的条件下，高效地调节这些资源的利用率，而不至于被网络中的垃圾交易所浪费。
在不同的应用场景中，对资源消耗的成本估算不尽相同，合理地设计交易费用可以实现参与方的共赢，推动应用的普及。
合理设计交易费用 如前文所述，交易费用的目的主要是：
 激励服务提供方即开发团队和节点 调节资源利用率   注：本文不考虑通证的通胀和其它的激励措施。
 节点和开发团队对交易费用分成，具体的比例由各方根据实际情况协调，并通过链上治理的方式进行动态的调整。
在区块链网络中，典型的资源和相应的费用设计方式如下：
 有限的区块大小，通过计算每笔交易占用的字节数来收取交易费； 有限的区块生成时间，通过计算或者性能测试得出不同交易所消耗的时间； 链上状态的存储资源，通常方式有一次性付费和租赁两种模式。一次性付费发生在交易处理过程中，在开发时对此费用评估。租赁模式还会考虑某个交易占据链上状态的时长，超时之后对相应状态进行清除。  Substrate 交易费用组成 Substrate作为一个通用的区块链应用开发框架，充分考虑了上面提到的各种因素。Substrate设计的交易费用由以下几部分组成：
总费用 = 基本费用 +（字节费用 + 权重费用）*（1 + 动态调节费率）+ 小费 用于支付的货币由transaction-payment模块的Currency类型指定，通常由Balances模块给出。
基本费用 即TransactionBaseFee，是每笔交易（特例请参考下面，通过pays_fee设置无付费的交易）都需支付的费用，定义在transaction-payment模块中，在runtime初始化时进行配置，并可以随着runtime的升级进行更新。基本费用的合理设置，可以有效的减少垃圾交易，例如Kusama网络的基本费用目前设置为 0.01 ksm。
字节费用 在处理区块大小的限制时，Substrate引入了最大区块长度和字节费用，system模块定义了最大区块长度（MaximumBlockLength），transaction-payment模块定义了每字节的费用（TransactionByteFee），总的字节费用为：
字节费用 = 每字节费用 * 字节数 和基本费用相同的是，每字节费用也是配置在可升级的runtime代码中。字节数的计算是按照交易的结构体通过SCALE编码之后的长度，应用开发者无需过多的关注。以Kusama网络为例，相关的设置如下：
 最大区块长度：5MB 每字节费用：0."><meta property="og:type" content="article"><meta property="og:url" content="https://kaichaosun.github.io/post/substrate_transaction_weight_and_fees/"><meta property="article:published_time" content="2020-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-21T00:00:00+00:00"><meta itemprop=name content="Substrate 区块链应用的交易费用设计"><meta itemprop=description content="[TOC]
通过本文，你将学到：
 区块链应用为什么存在交易费用 Substrate 交易费用的组成 如何设计更合理的交易费用  为什么存在交易费用 在传统物联网（web 2.0）时代，使用微信、微博、淘宝等互联网应用时，终端用户不需要直接费用，而是由服务提供方利用用户的个人信息、产生的数据、注意力等来变现，典型的方式有
 广告推送； 通过用户数据分析指导商家决策； 甚至直接共享、贩卖用户隐私等。  在使用以上所说的web 2.0服务时，用户数据的所有者是服务提供方。在过去的20年里，虽然我们享受了互联网应用带来的好处，但也时刻“品尝”着隐私泄露、数据主权丢失带来的恶果。
区块链应用将服务的各个组件完全透明化，用户数据的所有权归属于个人，而不是应用的开发者或者任何其他的第三方。用户通过持有私钥掌握着数据，只有持有私钥的人才可以解锁和转移数据，敏感数据往往可以通过加密防止被窃取。
任何区块链应用的出现和流行都离不开这些利益相关方：
 开发和运营团队 维护网络正常运行的节点 终端用户  “天下没有免费的晚餐”，终端用户在享受自由的应用服务同时，需要支付相应的服务费用，也就是交易费用，因为服务是由交易触发的。这些费用可以用来激励相关方更加有效的协作，从而提供更优质的服务。
交易费用的另一个目的是在网络和计算资源有限的条件下，高效地调节这些资源的利用率，而不至于被网络中的垃圾交易所浪费。
在不同的应用场景中，对资源消耗的成本估算不尽相同，合理地设计交易费用可以实现参与方的共赢，推动应用的普及。
合理设计交易费用 如前文所述，交易费用的目的主要是：
 激励服务提供方即开发团队和节点 调节资源利用率   注：本文不考虑通证的通胀和其它的激励措施。
 节点和开发团队对交易费用分成，具体的比例由各方根据实际情况协调，并通过链上治理的方式进行动态的调整。
在区块链网络中，典型的资源和相应的费用设计方式如下：
 有限的区块大小，通过计算每笔交易占用的字节数来收取交易费； 有限的区块生成时间，通过计算或者性能测试得出不同交易所消耗的时间； 链上状态的存储资源，通常方式有一次性付费和租赁两种模式。一次性付费发生在交易处理过程中，在开发时对此费用评估。租赁模式还会考虑某个交易占据链上状态的时长，超时之后对相应状态进行清除。  Substrate 交易费用组成 Substrate作为一个通用的区块链应用开发框架，充分考虑了上面提到的各种因素。Substrate设计的交易费用由以下几部分组成：
总费用 = 基本费用 +（字节费用 + 权重费用）*（1 + 动态调节费率）+ 小费 用于支付的货币由transaction-payment模块的Currency类型指定，通常由Balances模块给出。
基本费用 即TransactionBaseFee，是每笔交易（特例请参考下面，通过pays_fee设置无付费的交易）都需支付的费用，定义在transaction-payment模块中，在runtime初始化时进行配置，并可以随着runtime的升级进行更新。基本费用的合理设置，可以有效的减少垃圾交易，例如Kusama网络的基本费用目前设置为 0.01 ksm。
字节费用 在处理区块大小的限制时，Substrate引入了最大区块长度和字节费用，system模块定义了最大区块长度（MaximumBlockLength），transaction-payment模块定义了每字节的费用（TransactionByteFee），总的字节费用为：
字节费用 = 每字节费用 * 字节数 和基本费用相同的是，每字节费用也是配置在可升级的runtime代码中。字节数的计算是按照交易的结构体通过SCALE编码之后的长度，应用开发者无需过多的关注。以Kusama网络为例，相关的设置如下：
 最大区块长度：5MB 每字节费用：0."><meta itemprop=datePublished content="2020-02-21T00:00:00+00:00"><meta itemprop=dateModified content="2020-02-21T00:00:00+00:00"><meta itemprop=wordCount content="391"><meta itemprop=keywords content="Blockchain,Substrate,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Substrate 区块链应用的交易费用设计"><meta name=twitter:description content="[TOC]
通过本文，你将学到：
 区块链应用为什么存在交易费用 Substrate 交易费用的组成 如何设计更合理的交易费用  为什么存在交易费用 在传统物联网（web 2.0）时代，使用微信、微博、淘宝等互联网应用时，终端用户不需要直接费用，而是由服务提供方利用用户的个人信息、产生的数据、注意力等来变现，典型的方式有
 广告推送； 通过用户数据分析指导商家决策； 甚至直接共享、贩卖用户隐私等。  在使用以上所说的web 2.0服务时，用户数据的所有者是服务提供方。在过去的20年里，虽然我们享受了互联网应用带来的好处，但也时刻“品尝”着隐私泄露、数据主权丢失带来的恶果。
区块链应用将服务的各个组件完全透明化，用户数据的所有权归属于个人，而不是应用的开发者或者任何其他的第三方。用户通过持有私钥掌握着数据，只有持有私钥的人才可以解锁和转移数据，敏感数据往往可以通过加密防止被窃取。
任何区块链应用的出现和流行都离不开这些利益相关方：
 开发和运营团队 维护网络正常运行的节点 终端用户  “天下没有免费的晚餐”，终端用户在享受自由的应用服务同时，需要支付相应的服务费用，也就是交易费用，因为服务是由交易触发的。这些费用可以用来激励相关方更加有效的协作，从而提供更优质的服务。
交易费用的另一个目的是在网络和计算资源有限的条件下，高效地调节这些资源的利用率，而不至于被网络中的垃圾交易所浪费。
在不同的应用场景中，对资源消耗的成本估算不尽相同，合理地设计交易费用可以实现参与方的共赢，推动应用的普及。
合理设计交易费用 如前文所述，交易费用的目的主要是：
 激励服务提供方即开发团队和节点 调节资源利用率   注：本文不考虑通证的通胀和其它的激励措施。
 节点和开发团队对交易费用分成，具体的比例由各方根据实际情况协调，并通过链上治理的方式进行动态的调整。
在区块链网络中，典型的资源和相应的费用设计方式如下：
 有限的区块大小，通过计算每笔交易占用的字节数来收取交易费； 有限的区块生成时间，通过计算或者性能测试得出不同交易所消耗的时间； 链上状态的存储资源，通常方式有一次性付费和租赁两种模式。一次性付费发生在交易处理过程中，在开发时对此费用评估。租赁模式还会考虑某个交易占据链上状态的时长，超时之后对相应状态进行清除。  Substrate 交易费用组成 Substrate作为一个通用的区块链应用开发框架，充分考虑了上面提到的各种因素。Substrate设计的交易费用由以下几部分组成：
总费用 = 基本费用 +（字节费用 + 权重费用）*（1 + 动态调节费率）+ 小费 用于支付的货币由transaction-payment模块的Currency类型指定，通常由Balances模块给出。
基本费用 即TransactionBaseFee，是每笔交易（特例请参考下面，通过pays_fee设置无付费的交易）都需支付的费用，定义在transaction-payment模块中，在runtime初始化时进行配置，并可以随着runtime的升级进行更新。基本费用的合理设置，可以有效的减少垃圾交易，例如Kusama网络的基本费用目前设置为 0.01 ksm。
字节费用 在处理区块大小的限制时，Substrate引入了最大区块长度和字节费用，system模块定义了最大区块长度（MaximumBlockLength），transaction-payment模块定义了每字节的费用（TransactionByteFee），总的字节费用为：
字节费用 = 每字节费用 * 字节数 和基本费用相同的是，每字节费用也是配置在可升级的runtime代码中。字节数的计算是按照交易的结构体通过SCALE编码之后的长度，应用开发者无需过多的关注。以Kusama网络为例，相关的设置如下：
 最大区块长度：5MB 每字节费用：0."><meta name=twitter:site content="@https://twitter.com/kaichaosun"></head><body><nav class=main-nav><a href=https://kaichaosun.github.io/><span class=arrow>←</span>Home</a>
<a href=/about/>About</a>
<a class=cta href=#email-subscribe>Subscribe</a></nav><section id=wrapper><article class=post><header><h1>Substrate 区块链应用的交易费用设计</h1><h2 class=subtitle></h2><h2 class=headline>February 21, 2020<br><a href=https://kaichaosun.github.io/tags/blockchain>Blockchain</a>
<a href=https://kaichaosun.github.io/tags/substrate>Substrate</a></h2></header><aside><nav id=TableOfContents><ul><li><a href=#为什么存在交易费用>为什么存在交易费用</a></li><li><a href=#合理设计交易费用>合理设计交易费用</a></li><li><a href=#substrate-交易费用组成>Substrate 交易费用组成</a><ul><li><a href=#基本费用>基本费用</a></li><li><a href=#字节费用>字节费用</a></li><li><a href=#权重费用>权重费用</a></li><li><a href=#动态调节费率>动态调节费率</a></li><li><a href=#小费>小费</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#更多内容>更多内容</a></li><li><a href=#引用>引用</a></li></ul></nav></aside><section id=post-body><p>[TOC]</p><p>通过本文，你将学到：</p><ul><li>区块链应用为什么存在交易费用</li><li>Substrate 交易费用的组成</li><li>如何设计更合理的交易费用</li></ul><h2 id=为什么存在交易费用>为什么存在交易费用</h2><p>在传统物联网（web 2.0）时代，使用微信、微博、淘宝等互联网应用时，终端用户不需要直接费用，而是由服务提供方利用用户的个人信息、产生的数据、注意力等来变现，典型的方式有</p><ul><li>广告推送；</li><li>通过用户数据分析指导商家决策；</li><li>甚至直接共享、贩卖用户隐私等。</li></ul><p>在使用以上所说的web 2.0服务时，<strong>用户数据的所有者是服务提供方</strong>。在过去的20年里，虽然我们享受了互联网应用带来的好处，但也时刻“品尝”着隐私泄露、数据主权丢失带来的恶果。</p><p>区块链应用将服务的各个组件完全透明化，用户数据的所有权归属于个人，而不是应用的开发者或者任何其他的第三方。用户通过持有私钥掌握着数据，只有持有私钥的人才可以解锁和转移数据，敏感数据往往可以通过加密防止被窃取。</p><p>任何区块链应用的出现和流行都离不开这些利益相关方：</p><ul><li>开发和运营团队</li><li>维护网络正常运行的节点</li><li>终端用户</li></ul><p>“天下没有免费的晚餐”，终端用户在享受自由的应用服务同时，需要支付相应的服务费用，也就是交易费用，因为服务是由交易触发的。<strong>这些费用可以用来激励相关方更加有效的协作，从而提供更优质的服务</strong>。</p><p><strong>交易费用的另一个目的是在网络和计算资源有限的条件下，高效地调节这些资源的利用率</strong>，而不至于被网络中的垃圾交易所浪费。</p><p>在不同的应用场景中，对<strong>资源消耗的成本估算</strong>不尽相同，合理地设计交易费用可以实现参与方的共赢，推动应用的普及。</p><h2 id=合理设计交易费用>合理设计交易费用</h2><p>如前文所述，交易费用的目的主要是：</p><ul><li>激励服务提供方即开发团队和节点</li><li>调节资源利用率</li></ul><blockquote><p>注：本文不考虑通证的通胀和其它的激励措施。</p></blockquote><p>节点和开发团队对交易费用分成，具体的比例由各方根据实际情况协调，并通过链上治理的方式进行动态的调整。</p><p>在区块链网络中，典型的资源和相应的费用设计方式如下：</p><ul><li>有限的区块大小，通过计算每笔交易占用的字节数来收取交易费；</li><li>有限的区块生成时间，通过计算或者性能测试得出不同交易所消耗的时间；</li><li>链上状态的存储资源，通常方式有一次性付费和租赁两种模式。一次性付费发生在交易处理过程中，在开发时对此费用评估。租赁模式还会考虑某个交易占据链上状态的时长，超时之后对相应状态进行清除。</li></ul><h2 id=substrate-交易费用组成>Substrate 交易费用组成</h2><p>Substrate作为一个通用的区块链应用开发框架，充分考虑了上面提到的各种因素。Substrate设计的交易费用由以下几部分组成：</p><pre><code>总费用 = 基本费用 +（字节费用 + 权重费用）*（1 + 动态调节费率）+ 小费
</code></pre><p>用于支付的货币由transaction-payment模块的<a href=https://substrate.dev/rustdocs/master/pallet_transaction_payment/trait.Trait.html#associatedtype.Currency>Currency</a>类型指定，通常由<a href=https://github.com/paritytech/substrate/blob/master/bin/node/runtime/src/lib.rs#L198>Balances模块</a>给出。</p><h3 id=基本费用>基本费用</h3><p>即<a href=https://substrate.dev/rustdocs/master/pallet_transaction_payment/trait.Trait.html#associatedtype.TransactionBaseFee>TransactionBaseFee</a>，是每笔交易（特例请参考下面，通过pays_fee设置无付费的交易）都需支付的费用，定义在transaction-payment模块中，在runtime初始化时进行<a href=https://github.com/paritytech/substrate/blob/master/bin/node/runtime/src/lib.rs#L190>配置</a>，并可以随着runtime的升级进行更新。基本费用的合理设置，可以有效的减少垃圾交易，例如<a href=https://kusama.network/>Kusama网络</a>的基本费用目前设置为 0.01 ksm。</p><h3 id=字节费用>字节费用</h3><p>在处理区块大小的限制时，Substrate引入了最大区块长度和字节费用，system模块定义了<a href=https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.MaximumBlockLength>最大区块长度（MaximumBlockLength）</a>，transaction-payment模块定义了<a href=https://substrate.dev/rustdocs/master/pallet_transaction_payment/trait.Trait.html#associatedtype.TransactionByteFee>每字节的费用（TransactionByteFee）</a>，总的字节费用为：</p><pre><code>字节费用 = 每字节费用 * 字节数
</code></pre><p>和基本费用相同的是，每字节费用也是配置在可升级的runtime代码中。字节数的计算是按照交易的结构体通过<a href=https://substrate.dev/docs/en/conceptual/core/codec>SCALE编码</a>之后的长度，应用开发者无需过多的关注。以Kusama网络为例，相关的设置如下：</p><ul><li>最大区块长度：5MB</li><li>每字节费用：0.0001 ksm</li></ul><h3 id=权重费用>权重费用</h3><p>在有限的区块生成时间和链上状态的限制下，权重被用来定义交易产生的计算复杂度即所消耗的计算资源，以及占据的链上状态。system模块定义了<a href=https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.MaximumBlockWeight>区块的总权重（MaximumBlockWeight）</a>。为了保证在网络繁忙的情况下，依然能够实现对区块链应用有效合理的管理，Substrate引入了两种不同级别的交易类型，既 <a href=https://substrate.dev/rustdocs/master/frame_support/weights/enum.DispatchClass.html>Normal 和 Operational</a>。Normal类型的交易是由网络中的普通用户提交，Operational类型的交易是由网络中的管理员或者管理委员会共同触发。区块资源如<strong>长度</strong>和<strong>总权重</strong>按照一定比例在这两种类型的交易中进行分配，这一比例称为<a href=https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.AvailableBlockRatio>可用区块比（AvailableBlockRatio）</a>。Kusama网络的设置为：</p><ul><li>区块的总权重：1,000,000,000</li><li>可用区块比：75%，即Normal交易最多只占用75%的区块资源，Operational类型的交易则可以占用100%的区块资源，新的交易如果导致对应资源使用率超过阈值后，会被拒绝。</li></ul><p>交易（也称为可调用函数）权重设置的四种方式为：</p><p>第一，缺省，使用权重的默认值10,000，参考<a href=https://github.com/paritytech/substrate/blob/master/frame/support/src/weights.rs#L223>代码</a>。</p><p>第二，设置固定权重值和交易级别，<a href=https://substrate.dev/rustdocs/master/frame_support/weights/enum.SimpleDispatchInfo.html>SimpleDispatchInfo</a>定义了固定权重值的几种方式，</p><ul><li>FixedNormal，固定权重且为Normal级别的交易</li><li>InsecureFreeNormal，零权重且为Normal级别的交易</li><li>FixedOperational，固定权重且为Operational级别的交易</li></ul><p><strong>如何使用固定权重值</strong>，演示代码如下，完整代码请参考<a href=https://github.com/paritytech/substrate/blob/master/frame/example/src/lib.rs#L462-L491>example pallet</a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// 固定权重的Normal交易
</span><span style=color:#75715e></span><span style=color:#75715e>#[</span><span style=color:#75715e>weight = SimpleDispatchInfo::FixedNormal(10_000)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>accumulate_dummy</span>(origin, increase_by: <span style=color:#a6e22e>T</span>::Balance) -&gt; <span style=color:#a6e22e>DispatchResult</span> {
    <span style=color:#75715e>// --snip--
</span><span style=color:#75715e></span>}

<span style=color:#75715e>// 固定权重的Operational交易
</span><span style=color:#75715e></span><span style=color:#75715e>#[</span><span style=color:#75715e>weight = SimpleDispatchInfo::FixedOperational(2_000_000)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>accumulate_dummy</span>(origin, increase_by: <span style=color:#a6e22e>T</span>::Balance) -&gt; <span style=color:#a6e22e>DispatchResult</span> {
	<span style=color:#75715e>// --snip--
</span><span style=color:#75715e></span>}
</code></pre></div><p>第三，自定义权重计算方法，根据可调用函数的参数进行动态计算，需要一个自定义的结构体，实现<code>WeighData</code>、<code>ClassifyDispatch</code>和<code>PaysFee</code>接口。</p><ul><li>WeighData：当可调用函数使用某个自定义的权重计算方法时，用来获取该可调用函数的参数列表，并进行相关的计算得出权重。</li><li>ClassifyDispatch：获取可调用函数的参数列表，合理地判断出不同的交易级别即Normal/Operational。</li><li>PaysFee: 可以通过设置<code>pays_fee</code>为false，来避免收取任何交易费用（小费除外），适用于Operational交易存在权重值，但不收取交易费的场景。</li></ul><p><strong>如何自定义一个权重计算方法</strong>，<a href=https://github.com/paritytech/substrate/blob/master/frame/example/src/lib.rs#L502>example pallet</a> 中对应的演示代码为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// The rules of `WeightForSetDummy` are as follows:
</span><span style=color:#75715e></span><span style=color:#75715e>// - The final weight of each dispatch is calculated as the argument of the call multiplied by the
</span><span style=color:#75715e></span><span style=color:#75715e>//   parameter given to the `WeightForSetDummy`&#39;s constructor.
</span><span style=color:#75715e></span><span style=color:#75715e>// - assigns a dispatch class `operational` if the argument of the call is more than 1000.
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>WeightForSetDummy</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>pallet_balances</span>::Trait<span style=color:#f92672>&gt;</span>(BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>);

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>pallet_balances</span>::Trait<span style=color:#f92672>&gt;</span> WeighData<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> WeightForSetDummy<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
{
	<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>weigh_data</span>(<span style=color:#f92672>&amp;</span>self, target: (<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)) -&gt; <span style=color:#a6e22e>Weight</span> {
		<span style=color:#66d9ef>let</span> multiplier <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>;
		(<span style=color:#f92672>*</span>target.<span style=color:#ae81ff>0</span> <span style=color:#f92672>*</span> multiplier).saturated_into::<span style=color:#f92672>&lt;</span>Weight<span style=color:#f92672>&gt;</span>()
	}
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>pallet_balances</span>::Trait<span style=color:#f92672>&gt;</span> ClassifyDispatch<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> WeightForSetDummy<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
	<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>classify_dispatch</span>(<span style=color:#f92672>&amp;</span>self, target: (<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)) -&gt; <span style=color:#a6e22e>DispatchClass</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>target.<span style=color:#ae81ff>0</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span>::from(<span style=color:#ae81ff>1000</span><span style=color:#66d9ef>u32</span>) {
			DispatchClass::Operational
		} <span style=color:#66d9ef>else</span> {
			DispatchClass::Normal
		}
	}
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>pallet_balances</span>::Trait<span style=color:#f92672>&gt;</span> PaysFee<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> WeightForSetDummy<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
	<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pays_fee</span>(<span style=color:#f92672>&amp;</span>self, _target: (<span style=color:#f92672>&amp;</span>BalanceOf<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,)) -&gt; <span style=color:#66d9ef>bool</span> {
		<span style=color:#66d9ef>true</span>
	}
}

<span style=color:#e6db74>/// A type alias for the balance type from this module&#39;s point of view.
</span><span style=color:#e6db74></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>BalanceOf</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>T <span style=color:#66d9ef>as</span> pallet_balances::Trait<span style=color:#f92672>&gt;</span>::Balance;
</code></pre></div><p><strong>如何使用一个自定义的权重计算方法</strong>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[</span><span style=color:#75715e>weight = WeightForSetDummy::&lt;T&gt;(&lt;BalanceOf&lt;T&gt;&gt;::from(100u32))</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_dummy</span>(origin, <span style=color:#75715e>#[</span><span style=color:#75715e>compact</span><span style=color:#75715e>]</span> new_value: <span style=color:#a6e22e>T</span>::Balance) {
		<span style=color:#75715e>// --snip--
</span><span style=color:#75715e></span>}}
</code></pre></div><p>第四，使用Substrate预定义的<a href=https://substrate.dev/rustdocs/master/frame_support/weights/struct.FunctionOf.html><code>FunctionOf</code></a>结构体，适用于只有权重需要自定义进行计算，而交易级别固定的情况。FunctionOf接收三个数据，a) 一个根据参数计算权重的closure表达式; b) 固定交易级别或计算交易级别的closure; c) 设置<code>pays_fee</code>的布尔值。</p><p><strong>如何使用FunctionOf结构体</strong>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// weight = a x 10 + b
</span><span style=color:#75715e></span><span style=color:#75715e>#[</span><span style=color:#75715e>weight = FunctionOf(|args: (&amp;u32, &amp;u32)| args.0 * 10 + args.1, DispatchClass::Normal, true)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>f11</span>(_origin, _a: <span style=color:#66d9ef>u32</span>, _eb: <span style=color:#66d9ef>u32</span>) { unimplemented<span style=color:#f92672>!</span>(); }

<span style=color:#75715e>#[</span><span style=color:#75715e>weight = FunctionOf(|_: (&amp;u32, &amp;u32)| 0, DispatchClass::Operational, true)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>f12</span>(_origin, _a: <span style=color:#66d9ef>u32</span>, _eb: <span style=color:#66d9ef>u32</span>) { unimplemented<span style=color:#f92672>!</span>(); }
</code></pre></div><p><strong>注意</strong>：合理的权重值需要通过性能测试来获取，可以参考<a href=https://github.com/paritytech/substrate/pull/3157>PR Weight annotation</a>；可调用函数的文档中也要明确给出复杂度的计算公式，有多少存储类操作等。</p><p><strong>权重值需要转换为权重费用</strong>，transaction-payment 模块中给出了转换方式的定义<a href=https://github.com/paritytech/substrate/blob/master/frame/transaction-payment/src/lib.rs#L71>WeightToFee</a>，在runtime模块初始化时给出具体的实现代码，例如在Kusama网路，<a href=https://github.com/paritytech/polkadot/blob/master/runtime/common/src/impls.rs#L78-L95>WeightToFee的实现</a>为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>WeightToFee</span>;

<span style=color:#66d9ef>impl</span> Convert<span style=color:#f92672>&lt;</span>Weight, Balance<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> WeightToFee {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>convert</span>(x: <span style=color:#a6e22e>Weight</span>) -&gt; <span style=color:#a6e22e>Balance</span> {
      	<span style=color:#75715e>// in Polkadot a weight of 10_000 (smallest non-zero weight) to be mapped to 10^7 units of
</span><span style=color:#75715e></span>      	<span style=color:#75715e>// fees (1/10 CENT), hence:
</span><span style=color:#75715e></span>      	Balance::from(x).saturating_mul(<span style=color:#ae81ff>1_000</span>)
    }
}
</code></pre></div><h3 id=动态调节费率>动态调节费率</h3><p>节点的runtime代码中，需要配置<code>TargetBlockFullness</code>参数，通常为25%，即在网络平稳运行的过程中，区块资源的使用比例应该稳定在25%左右。当当前区块资源使用超过25%时，将下一区块动态调节费率设置为正，增加交易费用；当资源使用率不足25%时，将下一区块的动态调节费率设置为负，减少交易费用，鼓励交易的发生。这一规则的实现依赖transaction-payment模块的<a href=https://github.com/paritytech/substrate/blob/master/frame/transaction-payment/src/lib.rs#L74>FeeMultiplierUpdate</a>，Kusama对应的实现代码请参考<a href=https://github.com/paritytech/polkadot/blob/master/runtime/common/src/impls.rs#L97-L149>这里</a>。</p><h3 id=小费>小费</h3><p>西方文化中一个特别之处是，当享用别人提供的优质服务时，会主动给出小费，这种思想也出现在Substrate的设计之中。和现实生活中的小费概念相同，它不是必须的，具体数量由交易发送者任意决定，并且完全由区块生产者获得，而交易费用的其它组成部分会根据一定的比例分配进入“国库”。</p><h2 id=总结>总结</h2><p>通过本文，你已经对交易费用有了基本的认识，以及如何合理地使用Substrate提供的交易费用规则。关于交易费用，已经有人在进行一些新的尝试，如：</p><ul><li>完全没有交易费用，由各个参与方自发组建去中心的网络；</li><li>对不同的稀缺资源收取一定的租赁费用。</li></ul><h2 id=更多内容>更多内容</h2><p>官方文档：<a href=https://substrate.dev/>substrate.dev</a></p><p>Parity介绍：<a href=https://www.parity.io/>parity.io</a></p><h2 id=引用>引用</h2><p><a href=https://substrate.dev/docs/en/conceptual/runtime/weight>Transaction Weight</a></p><p><a href=https://substrate.dev/docs/en/next/development/module/fees>Transaction Fees</a></p><p><a href=https://hackmd.io/UD0HojfARqyUMC9Jxs5-RA>Weights for Pallet Functions</a></p><p><a href=https://research.web3.foundation/en/latest/polkadot/Token%20Economics.html#relay-chain-transaction-fees-and-per-block-transaction-limits>Relay-chain transaction fees and per-block transaction limits</a></p><p><a href=https://github.com/paritytech/substrate/pull/3157>Weight annotation</a></p></section></article><footer id=post-meta class=clearfix><a href=https://twitter.com/kaichaosun><img class=avatar src=https://kaichaosun.github.io/images/avatar.png><div><span class=dark>Kaichao Sun</span>
<span>Mark it down</span></div></a><section id=sharing><a class=twitter href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkaichaosun.github.io%2fpost%2fsubstrate_transaction_weight_and_fees%2f - Substrate%20%e5%8c%ba%e5%9d%97%e9%93%be%e5%ba%94%e7%94%a8%e7%9a%84%e4%ba%a4%e6%98%93%e8%b4%b9%e7%94%a8%e8%ae%be%e8%ae%a1 by @kaichaosun"><span class=icon-twitter>tweet</span></a>
<a class=facebook href=# onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;"><span class=icon-facebook-rect>Share</span></a></section></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"whisperd"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><ul id=post-list class="archive readmore"><iframe src=https://kaichao.substack.com/embed id=email-subscribe width=100% height=320 style="border:1px solid #eee;background:#fff;margin-top:60px" frameborder=0 scrolling=no></iframe><h3>Read more</h3><li><a href=/post/substrate_history/>Substrate 技术演进<aside class=dates>Jan 22 2022</aside></a></li><li><a href=/post/metaverse/>元宇宙会不会把我们从一条人变成一条狗？<aside class=dates>Jan 21 2022</aside></a></li><li><a href=/post/substrate_network_libp2p/>Substrate 如何使用 libp2p 进行点对点通信<aside class=dates>Feb 8 2021</aside></a></li><li><a href=/post/substrate_read_source_code/>阅读Substrate源码的方法<aside class=dates>Jan 6 2021</aside></a></li><li><a href=/post/learn_substrate/>如何学习Substrate<aside class=dates>Jul 20 2020</aside></a></li><li><a href=/post/substrate_launch_public_testnet/>Substrate 部署公开测试网络<aside class=dates>Jul 17 2020</aside></a></li><li><a href=/post/how_to_blockchain/>如何学习区块链技术<aside class=dates>Apr 30 2020</aside></a></li><li><a href=/post/kusama_governance/>Kusama系列：如何进行链上治理<aside class=dates>Apr 16 2020</aside></a></li><li><a href=/post/substrate_node_template_guide/>Substrate代码导读：node-template<aside class=dates>Apr 2 2020</aside></a></li><li><a href=/post/trie/>理解Substrate数据存储的底层实现Merkle Patricia Trie<aside class=dates>Mar 17 2020</aside></a></li><li><a href=/post/substrate_storage_data_type/>Substrate存储数据类型概览<aside class=dates>Jan 19 2020</aside></a></li><li><a href=/post/coin_flip_test_and_ui/>抛硬币游戏(二)：编写测试和UI<aside class=dates>Oct 3 2019</aside></a></li><li><a href=/post/substrate_metadata/>Substrate Runtime Metadata<aside class=dates>Sep 7 2019</aside></a></li><li><a href=/post/substrate_coin_flip/>Substrate应用 - 抛硬币游戏(一)<aside class=dates>Aug 5 2019</aside></a></li><li><a href=/post/substrate_module_struct/>Substrate Module Struct<aside class=dates>Jul 30 2019</aside></a></li><li><a href=/post/substrate_blockchain_setup/>使用Substrate搭建你的第一条区块链<aside class=dates>May 28 2019</aside></a></li><li><a href=/post/why_oo_sucks/>Why OO Sucks<aside class=dates>Apr 25 2019</aside></a></li><li><a href=/post/solidity-basics/>理解Ethereum智能合约开发<aside class=dates>Apr 11 2019</aside></a></li><li><a href=/post/shell-cheatsheet/>Cheatsheet for Shell Programming<aside class=dates>Mar 30 2019</aside></a></li><li><a href=/post/master_linux_os/>The Tutorial of Manjaro Linux Usage<aside class=dates>Mar 3 2019</aside></a></li></ul><footer id=footer><div id=social><a class=symbol href=https://github.com/kaichaosun><i class="fa fa-github"></i></a><a class=symbol href=https://twitter.com/kaichaosun><i class="fa fa-twitter"></i></a></div><p class=small>© Copyright 2022 Kaichao Sun</p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://kaichaosun.github.io/js/main.js></script><script src=https://kaichaosun.github.io/js/highlight.js></script><script src=https://kaichaosun.github.io/js/fix-toc.js></script><script>hljs.initHighlightingOnLoad();</script><script data-ad-client=ca-pub-2513693433628672 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-128168145-1','auto');ga('send','pageview');}</script></body></html>