<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Kaichao Sun">
<meta name="description" content="dasheng&#39;s blog">
<meta name="generator" content="Hugo 0.49.2" />
<title>Understand Monad in Functional Programming</title>
<link rel="shortcut icon" href="https://whisperd.tech/images/favicon.ico">
<link rel="stylesheet" href="https://whisperd.tech/css/style.css">
<link rel="stylesheet" href="https://whisperd.tech/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">



<link href="https://whisperd.tech/index.xml" rel="alternate" type="application/rss+xml" title="Whisperd" />


<meta property="og:title" content="Understand Monad in Functional Programming" />
<meta property="og:description" content="Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have procedure-oriented programming. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whisperd.tech/post/understand-monad/" /><meta property="article:published_time" content="2018-10-13T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-10-13T00:00:00&#43;00:00"/>



<meta itemprop="name" content="Understand Monad in Functional Programming">
<meta itemprop="description" content="Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have procedure-oriented programming. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet.">


<meta itemprop="datePublished" content="2018-10-13T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-10-13T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1791">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understand Monad in Functional Programming"/>
<meta name="twitter:description" content="Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have procedure-oriented programming. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet."/>
<meta name="twitter:site" content="@https://twitter.com/SunWillsuna"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://whisperd.tech'> <span class="arrow">←</span>Home</a>
	

	
 		<a href='/about/'>About</a>
  	

	

	
		<a class="cta" href="https://whisperd.tech/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        

<article class="post">
    <header>
        <h1>Understand Monad in Functional Programming</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        October 13, 2018
        <br>
        
        </h2>
    </header>

    <aside>
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#why-functional-programming">Why Functional Programming?</a></li>
<li><a href="#pure-function">Pure Function</a></li>
<li><a href="#function-composition">Function Composition</a></li>
<li><a href="#monad">Monad</a>
<ul>
<li><a href="#define-a-monad">Define a Monad</a></li>
<li><a href="#monad-laws">Monad Laws</a></li>
</ul></li>
<li><a href="#free-monad">Free Monad</a>
<ul>
<li><a href="#why-need-it">Why need it</a></li>
<li><a href="#how-to-use">How to use</a></li>
<li><a href="#what-s-the-implementation">What&rsquo;s the implementation</a></li>
</ul></li>
<li><a href="#monad-transformer">Monad transformer</a>
<ul>
<li><a href="#why-need-it-1">Why need it</a></li>
<li><a href="#how-to-use-1">How to use</a></li>
<li><a href="#what-s-the-implementation-1">What&rsquo;s the implementation</a></li>
</ul></li>
<li><a href="#extensible-effect">Extensible Effect</a>
<ul>
<li><a href="#why-need-it-2">Why need it</a></li>
<li><a href="#how-to-use-2">How to use</a></li>
<li><a href="#what-s-the-implementation-2">What&rsquo;s the implementation</a></li>
</ul></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
</nav>
    </aside>

    <section id="post-body">
        

<h2 id="why-functional-programming">Why Functional Programming?</h2>

<p>The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have <strong>procedure-oriented programming</strong>. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with <strong>OOP</strong> with the <strong>SOLID</strong> principles to guide the daily dev work.</p>

<p>If there is one rule in software development, i think that must be <code>no silver bullet</code>. The OOP has ruled the system development for more that 20 years (The number comes from JAVA becomes popularity). More and more devs find object-oriented programming sucks:</p>

<ul>
<li>Mutable state of instances, variables</li>
<li>Hard to conform with SOLID when business logic becomes messy</li>
<li>Hard to test caused by improper DI</li>
<li>So many lines of code</li>
<li>Boring &hellip;</li>
</ul>

<p>Now people are thinking how to solve them:</p>

<ul>
<li>There is no mutable variables</li>
<li>The functionality should be encapsulated</li>
<li>I don&rsquo;t want exception, the compute unit (AKA function) should be pure</li>
<li>The code should be clean</li>
<li>Easy to test</li>
<li>Parallelism</li>
<li>Make me happy &hellip;</li>
</ul>

<p>That&rsquo;s what the FP try to implemented. What&rsquo;s the design principle for FP? Category theory. It&rsquo;s simple as its name. As the saying goes, there is no silver bullet.</p>

<p>What sucks in FP?</p>

<ul>
<li>Learning curve</li>
<li>Too young</li>
<li>The world is not perfect</li>
<li><em>Please add more</em> &hellip;</li>
</ul>

<h2 id="pure-function">Pure Function</h2>

<p>A function can be pure or impure. Usually we use pure function in FP as much as we can. There are a few conditions for pure function:</p>

<ol>
<li>Give the same input argument to the function, it should always return same output.</li>
<li>The function should only depends on the return value to change the whole &ldquo;world&rdquo;, which means no side effects. The side effects can be an exception, mutate an object, IO operation, etc.</li>
</ol>

<p>I will give one example to understand pure function:</p>

<pre><code class="language-scala">// pure function
def add(i: Int, y: Int) =
  i + y

// impure function
def addAndPrint(i: Int, y: Int) = {
  val result = i + y
  println(s&quot;The result is ${result}&quot;)
  result
}
</code></pre>

<p>A short summary is:</p>

<ul>
<li>Output depends only on input.</li>
<li>No side effects</li>
</ul>

<p>With pure function, it&rsquo;s possible to make sure our program is <strong>referential transparency</strong> which means that an expression always evaluate to the same result in any piece of code. Referential transparency makes the code easier to reason about.</p>

<p>What can be done if we don&rsquo;t read any inputs and write any outputs?</p>

<p>Usually, we can refactor impure function to be pure by adding a proper <strong>context</strong> (here a context is what a value wrapped in.) like <strong>Option</strong>, <strong>cats.effect.IO</strong> or <strong>monix.eval.Task</strong> to the function return type. Some cases are:</p>

<ul>
<li>Use <strong>Either</strong> to represent exception</li>
<li>Use <strong>IO</strong> or <strong>Task</strong> to delay the I/O operation</li>
</ul>

<h2 id="function-composition">Function Composition</h2>

<p>Basicly, FP is about fucntion composition. That means:</p>

<pre><code class="language-scala">// A, B, C are types
f: A -&gt; B, 
g: B -&gt; C, 
g compose f: A -&gt; C
</code></pre>

<p>But how should we deal with the values wrapped in context like Option or IO? There could be lots of scheleton code if we still use simple function composition in this case. Then, there comes <strong>monad</strong>, it opens the context and keeps the context same in the following computation. Usually we use for comprehension to simplise the control flow:</p>

<pre><code class="language-scala">val result = for {
  a &lt;- Option.apply(1) // this is equal to Some(1)
  b &lt;- Option.apply(2)
} yield a + b

// result is: Some(3)
</code></pre>

<h2 id="monad">Monad</h2>

<h3 id="define-a-monad">Define a Monad</h3>

<p>In this section, we will implement an &lsquo;ugly&rsquo; Option monad, without considering any variance in type marameter:</p>

<pre><code class="language-scala">sealed trait Option[+A] {
  def flatMap[B](func: A =&gt; Option[B]): Option[B] =
    this match {
      case None =&gt; None
      case Some(a) =&gt; func(a)
    }
  
  def map[B](func: A =&gt; B): Option[B] =
    this match {
      case None =&gt; None
      case Some(a) =&gt; Some(func(a))
    }
}
case object None extends Option[Nothing]
case class Some[T](value: T) extends Option[T]
</code></pre>

<p>The usage of this either monad:</p>

<pre><code class="language-scala">val finalEither = for {
    a &lt;- Right[String, Int](1)
    b &lt;- Right[String, Int](2)
  } yield (a + b)
</code></pre>

<h3 id="monad-laws">Monad Laws</h3>

<p>When defining monad, it should follow a few laws, these laws maintain the basics of a category.</p>

<p>Identity law:</p>

<pre><code class="language-scala">def unit[A](a: A): F[A]
def f[A](a: A): F[A]

// With same a, the following equation should be met.
f(a).flatMap(unit) == f(a)
unit(a).flatMap(f) == f(a)
</code></pre>

<p>Associative law:</p>

<pre><code class="language-scala">// x is a F[A]
x.flatMap(f).flatMap(g) == x.flatMap(a =&gt; f(a).flatMap(g))
</code></pre>

<h2 id="free-monad">Free Monad</h2>

<h3 id="why-need-it">Why need it</h3>

<p>There is developers want to decomose data from the interpreter, which means there can be multiple interpretation for the same piece of computation. It would be helpful if we want to invoke different computation in different place. In this case, we need to wrap such computation in a context which can be composed with the computation in same context. This is a special monad which is called free. Typically ADT is common used to represent the data.</p>

<h3 id="how-to-use">How to use</h3>

<p>In practice, we can view <strong>Free</strong> as a clever way of forming <strong>Monad</strong> with providing <strong>Functor</strong>.</p>

<p>Following steps show the way to use free monad provides by cats library (need to add <code>cats-free</code> dependency):</p>

<p>1. Create custome ADT to represent the operation:</p>

<pre><code class="language-scala">   sealed trait KVStoreA[A]
   
   case class Put[T](key: String, value: T) extends KVStoreA[Unit]
   case class Get[T](key: String) extends KVStoreA[Option[T]]
   case class Delete(key: String) extends KVStoreA[Unit]
</code></pre>

<p>2. Define free monad with Free for above ADT:</p>

<pre><code class="language-scala">   import cats.free.Free
   
   // We haven't define Functor, but use CoYoneda[F, _] is functor for any F.
   type KVStore[A] = Free[KVStoreA, A]
</code></pre>

<p>3. Using <strong>liftF</strong> Create DSL related functions which return above free monad:</p>

<pre><code class="language-scala">   import cats.free.Free.liftF
      
   // Put returns nothing (i.e. Unit).
   def put[T](key: String, value: T): KVStore[Unit] =
     liftF[KVStoreA, Unit](Put[T](key, value))
      
   // Get returns a T value.
   def get[T](key: String): KVStore[Option[T]] =
     liftF[KVStoreA, Option[T]](Get[T](key))
      
   // Delete returns nothing (i.e. Unit).
   def delete(key: String): KVStore[Unit] =
     liftF(Delete(key))
      
   // Update composes get and set, and returns nothing.
   def update[T](key: String, f: T =&gt; T): KVStore[Unit] =
     for {
       vMaybe &lt;- get[T](key)
        _ &lt;- vMaybe.map(v =&gt; put[T](key, f(v))).getOrElse(Free.pure(()))
     } yield ()
</code></pre>

<p>4. Build a program with constructed function:</p>

<pre><code class="language-scala">   def program: KVStore[Option[Int]] =
     for {
       _ &lt;- put(&quot;cats&quot;, 2)
       _ &lt;- update[Int](&quot;cats&quot;, (_ + 12))
       n &lt;- get[Int](&quot;cats&quot;)
       _ &lt;- delete(&quot;cats&quot;)
     } yield n
</code></pre>

<p>5. Implement the interpreter which is a natural transformation to interpret each operation:</p>

<pre><code class="language-scala">   import cats.{Id, ~&gt;}
   import scala.collection.mutable
   
   def impureCompiler: KVStoreA ~&gt; Id  =
     new (KVStoreA ~&gt; Id) {
   
       // a very simple (and imprecise) key-value store
       val kvs = mutable.Map.empty[String, Any]
   
       def apply[A](fa: KVStoreA[A]): Id[A] =
         fa match {
           case Put(key, value) =&gt;
             println(s&quot;put($key, $value)&quot;)
             kvs(key) = value
             ()
           case Get(key) =&gt;
             println(s&quot;get($key)&quot;)
             kvs.get(key).map(_.asInstanceOf[A])
           case Delete(key) =&gt;
             println(s&quot;delete($key)&quot;)
             kvs.remove(key)
             ()
         }
     }
</code></pre>

<p>6. Run the program with defined interpreter:</p>

<pre><code class="language-scala">   // Free[_] is just a recursive structure, which similar to List.
   val result: Option[Int] = program.foldMap(impureCompiler)
</code></pre>

<h3 id="what-s-the-implementation">What&rsquo;s the implementation</h3>

<p>The implementation of free monad, details go to this <a href="https://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html">post</a>:</p>

<pre><code class="language-scala">sealed trait Free[F[_], A] {
  def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Return(a)  =&gt; f(a)
      case Suspend(s) =&gt; Suspend(s map (_ flatMap f))
    }
}

final case class Return[F[_], A](a: A) extends Free[F, A]
final case class Suspend[F[_], A](s: F[Free[F, A]]) extends Free[F, A]

object Free {
  def point[F[_]](a: A): Free[F, A] = Return[F, A](a)
}
</code></pre>

<p>Usually, we will have a lot of ADTs in the code, but unrelated monad do not compose. Cats has given an option to chain the different ADT by using <strong>coproduct</strong> type. We are not going to discuss the detail here, but worth to dig it more <a href="https://www.47deg.com/blog/fp-for-the-average-joe-part3-free-monads/">here</a> if you are interested.</p>

<h2 id="monad-transformer">Monad transformer</h2>

<h3 id="why-need-it-1">Why need it</h3>

<p>Imagine there is a piece of code to fetch the address of a user by its id:</p>

<pre><code class="language-scala">def findUserById(id: Long): Future[User] = ???
def findAddressByUser(user: User): Future[Address] = ???
</code></pre>

<p>We can use for-comprehension to control the workflow since they share the same context Future and Future has a build-in <code>flatMap</code>.</p>

<pre><code class="language-scala">def findAddressByUserId(id: Long): Future[Address] =
  for {
    user    &lt;- findUserById(id)
    address &lt;- findAddressByUser(user)
  } yield address
</code></pre>

<p>There is a situation that we can&rsquo;t find a user if the id is not exist, event the address can be optional for a user.</p>

<pre><code class="language-scala">def findUserById(id: Long): Future[Option[User]] = ???
def findAddressByUser(user: User): Future[Option[Address]] = ???
</code></pre>

<p>Then the workflow need to be changed:</p>

<pre><code class="language-scala">def findAddressByUserId(id: Long): Future[Option[Address]] =
  findUserById(id).flatMap {
    case Some(user) =&gt; findAddressByUser(user)
    case None       =&gt; Future.successful(None)
  }
</code></pre>

<p>It&rsquo;s working but not as beautiful as previous. Now we comes to monad transformers.</p>

<h3 id="how-to-use-1">How to use</h3>

<p>Use <strong>OptionT</strong> provided by cats in for-comprehension:</p>

<pre><code class="language-scala">def findAddressByUserIdOptionT(id: Long): OptionT[Future, Address] =
  for {
    user &lt;- OptionT(findUserById(id))
    address &lt;- OptionT(findAddressByUser(user))
  } yield address
</code></pre>

<h3 id="what-s-the-implementation-1">What&rsquo;s the implementation</h3>

<p>The brief definition of OptionT:</p>

<pre><code class="language-scala">case class OptionT[F[_], A](value: F[Option[A]]) {
  def map[B](f: A =&gt; B)(implicit F: Functor[F]): OptionT[F, B] =
    OptionT(value.map(_.map(f)))

  def flatMap[B](f: A =&gt; OptionT[F, B])(implicit F: Monad[F]): OptionT[F, B] =
    OptionT(value.flatMap(
      _.fold(Option.empty[B].pure[F])(
        f andThen ((fa: OptionT[F, B]) =&gt; fa.value))))
}
object OptionT {
  def pure[F[_]: Applicative, A](a: A): OptionT[F, A] =
    OptionT(a.pure[Option].pure[F])
}
</code></pre>

<p>One thing need to mention is that many monad transformers could be stack unsafe, like <code>StateT</code> .</p>

<h2 id="extensible-effect">Extensible Effect</h2>

<h3 id="why-need-it-2">Why need it</h3>

<p>Monad transformers has a limited nest layers, also must keep the order same in different computation. What if we have some super way to rule all the monads? In this case we can walk through the control flow without worring the different monad. Finally it will free us from assembling different manads.</p>

<p>The principle ideas to understand effects are:</p>

<blockquote>
<ul>
<li>An effect is most easily understood as an interaction between a sub-expression and a central authority that administers the global resources of a program.</li>
<li>An effect can be viewed as a message to the central authority plus enough information to resume the suspended calculation.</li>
</ul>
</blockquote>

<h3 id="how-to-use-2">How to use</h3>

<pre><code class="language-scala">type Stack = Fx.fx2[Option, StringEither]

type HasOption[R] = MemberIn[Option, R]
type StringEither[A] = Either[String, A]
type HasEither[R] = MemberIn[StringEither, R]

def program[R: HasOption: HasEither] = for {
  a &lt;- fromOption(Some(1))
  b &lt;- fromEither(Right(2))
} yield a + b

println(program[Stack])
println(program[Stack].asInstanceOf[ImpureAp[_, _, _]].continuation.functions)

val result = program[Stack].runOption.runEither.run // Right(Some(3))
</code></pre>

<h3 id="what-s-the-implementation-2">What&rsquo;s the implementation</h3>

<p>The core of Eff library is Eff monad and the open union. Defining effects and their interactions is done by the user. There are some common effects provided by the library like ReaderEffect, IOEffect etc for convenience.</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="http://okmij.org/ftp/Computation/free-monad.html">Free and Freer Monads: Putting Monads Back into Closet</a></li>
<li><a href="https://alvinalexander.com/scala/fp-book/pure-functions-and-io-input-output">Pure Functions and I/O</a></li>
<li><a href="http://degoes.net/articles/only-one-io">There Can Be Only One&hellip;IO Monad</a></li>
<li><a href="https://monix.io/blog/2018/03/20/monix-vs-cats-effect.html">Monix’s Task vs cats.effect.IO</a></li>
<li><a href="https://underscore.io/blog/posts/2015/04/28/monadic-io-laziness-makes-you-free.html">Monadic IO: Laziness Makes You Free</a></li>
<li><a href="http://degoes.net/articles/only-one-io">There Can Be Only One&hellip;IO Monad</a></li>
<li><a href="https://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from">Where does the term “Monad” come from?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Monad (functional programming) in Wikipedia</a></li>
<li><a href="https://typelevel.org/cats/datatypes/freemonad.html">Free Monad in Cats</a></li>
<li><a href="https://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html">Deriving the Free Monad</a></li>
<li><a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></li>
<li><a href="http://blog.higher-order.com/assets/scalaio.pdf">Purely Functional I/O in Scala</a></li>
<li><a href="http://blog.higher-order.com/assets/trampolines.pdf">Stackless Scala With Free Monads</a></li>
<li><a href="https://blog.buildo.io/monad-transformers-for-the-working-programmer-aa7e981190e7">Monad Transformers for the working programmer</a></li>
<li><a href="https://typelevel.org/cats/datatypes/optiont.html">Cats: OptionT</a></li>
<li><a href="http://degoes.net/articles/effects-without-transformers">No More Transformers: High-Performance Effects in Scalaz 8</a></li>
<li><a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a></li>
<li><a href="https://wiki.haskell.org/Referential_transparency">Referential transparency</a></li>
</ul>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    <a href="https://twitter.com/SunWillsuna">
    <img class="avatar" src="https://whisperd.tech/images/avatar.png">
    <div>
        <span class="dark">Kaichao Sun</span>
        <span>Mark it down</span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fwhisperd.tech%2fpost%2funderstand-monad%2f - Understand%20Monad%20in%20Functional%20Programming by @SunWillsuna"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "whisperd" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/post/solidity-basics/">理解Ethereum智能合约开发<aside class="dates">Apr 11 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/shell-cheatsheet/">Cheatsheet for Shell Programming<aside class="dates">Mar 30 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/master_linux_os/">The Tutorial of Manjaro Linux Usage<aside class="dates">Mar 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/laozhai-jiyi/">老宅记忆<aside class="dates">Feb 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/dependency_injection_in_scala/">(WIP) Dependency Injection in Scala<aside class="dates">Jan 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/error_handling_in_scala/">Understand Error Handling in Scala<aside class="dates">Jan 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/common-cli-cheatsheet/">Cheatsheet for Common Usage CLI<aside class="dates">Jan 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/kubernetes-basics/">Kubernetes basics<aside class="dates">Jun 21 2018</aside></a>
        </li>
    
        <li>
            <a href="/post/how-to-setup-iri/">如何部署 IOTA 的 IRI headless 全节点<aside class="dates">Dec 17 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/go-channel/">理解Golang并发编程<aside class="dates">Jul 29 2017</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/dashengSun">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/SunWillsuna">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2019 Kaichao Sun
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://whisperd.tech/js/main.js"></script>
<script src="https://whisperd.tech/js/highlight.js"></script>
<script src="https://whisperd.tech/js/fix-toc.js"></script>
<script src="https://whisperd.tech/js/gulugulu.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2513693433628672",
    enable_page_level_ads: true
  });
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-128168145-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
