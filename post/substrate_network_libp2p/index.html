<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kaichao Sun"><meta name=description content="kaichao's blog"><meta name=generator content="Hugo 0.62.2"><title>Substrate 如何使用 libp2p 进行点对点通信</title><link rel="shortcut icon" href=https://kaichaosun.github.io/images/favicon.ico><link rel=stylesheet href=https://kaichaosun.github.io/css/style.css><link rel=stylesheet href=https://kaichaosun.github.io/css/highlight.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css><meta property="og:title" content="Substrate 如何使用 libp2p 进行点对点通信"><meta property="og:description" content="通过本文，你将了解到，
 点对点通信的特点； libp2p的基本介绍； 以及Substrate如何使用libp2p实现点对点的通信。  点对点通信 在Web2.0时代，绝大多数互联网应用采用了基于TCP/IP的“客户端-服务器”通信架构，在客户端采集数据并发送给服务器，服务器存储和处理数据，客户端进而获取并使用这些处理后的数据。这种模式支撑了互联网近三十年的蓬勃发展，在给普通用户提供便利的同时，也出现了各种各样的问题，比如：
 泄露用户隐私； 贩卖用户数据； 服务商发布没有底线的广告给不明真相的用户造成不可挽回的损失； 不经协商，随意删除用户发布的内容； 垄断市场和定价； 过度利用用户心理，无节制地占据用户的时间； &mldr;&mldr;  客户端-服务器通信模型如下图：
在为以上问题寻找解决方案时，点对点（即peer to peer）的通信机制逐渐走进了技术先驱们的视野。在互联网早期的时候，点对点通信主要用于文件共享，如音乐共享服务Napster和流媒体下载服务BitTorrent。点对点服务更加广泛的应用，还需要一定的治理机制，来处理资源的版权问题和现实世界的监管，这些不是本文的重点，不做过多地介绍。
点对点通信模型如下图：
在点对点的网络里，所有的节点都是对等的，即任何节点都可以存储和处理数据（作为服务端）；也可以发送待处理的数据给网络中的其它节点，获取经过网络处理后的数据（作为客户端）。通过这样的通信机制，可以保证，
 网络具备开放性，节点可以自由加入和退出； 不依赖单一服务节点，网络的服务更加可靠、高效； 节点运行的程序代码公开可见，规则更加透明。  根据网络中传输的数据和提供服务的不同，点对点应用出现了不同的应用场景，包括文件存储和读取、数据计算、内容共享、数据交易等服务。在开发这些应用的过程中，可能涉及到的技术要点有：
  节点身份，唯一地标识网络中的节点及地址格式；
  发现机制，在没有中心化的协调服务存在的情况下，如何发现新的节点；
  路由，本地节点无法存储网络中所有节点的信息，通过路由算法查找需要的节点；
  多种通信协议比如TCP、UDP、WebSocket、QUIC等等；
  加密和认证，保证消息的可靠和安全；
  NAT穿透，解决NAT后面的内部IP无法访问的难题；
  多路复用以节省资源；
  消息订阅，高效的获取更新而不会给网络造成负担；
  中继，当需要建立通信的两个节点都无法直接被访问，比如都在NAT网络中，需要通过中继节点传递信息；
  &mldr;&mldr;
  以上列出的这些技术要点/需求并不会出现在每个点对点应用里，大多数只会使用其中的一部分功能，尽管如此，还是存在严重地重复造轮子的现象。也有一些应用为了避免重复开发，选择了fork已有开源应用的功能代码，这种方式引入了原有应用的技术债，难于定制和扩展。
复杂多变的网络拓扑和膨胀的应用状态导致了点对点应用的开发、推广和普及都极为困难，出现一个高度模块化的点对点通信开发框架也就不足为奇，也就是接下来我们要介绍的libp2p。
Libp2p 介绍 Libp2p是一个开发点对点应用的框架，它最早源于去中心的文件共享服务IPFS，把网络通信相关的内容抽离并重新设计，形成了现在的libp2p，目前比较成熟的几个语言版本包括js-libp2p、go-libp2p、rust-libp2p，并且定义了一套参考规范，不同语言的实现版本只要符合这一规范，就可以实现互通信。
Libp2p提供的核心功能包括，
 在节点之间建立安全可复用的网络连接； 可验证的节点身份和可连接的地址。  安全可复用的连接 Libp2p支持的底层（传输层）协议包括TCP/IP、UDP、WebSocket、QUIC等，不同语言版本的实现完成度不尽相同。连接的安全性是通过对传输内容进行加密来保证的，节点的身份也会进行相应的验证。"><meta property="og:type" content="article"><meta property="og:url" content="https://kaichaosun.github.io/post/substrate_network_libp2p/"><meta property="article:published_time" content="2021-02-08T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-08T00:00:00+00:00"><meta itemprop=name content="Substrate 如何使用 libp2p 进行点对点通信"><meta itemprop=description content="通过本文，你将了解到，
 点对点通信的特点； libp2p的基本介绍； 以及Substrate如何使用libp2p实现点对点的通信。  点对点通信 在Web2.0时代，绝大多数互联网应用采用了基于TCP/IP的“客户端-服务器”通信架构，在客户端采集数据并发送给服务器，服务器存储和处理数据，客户端进而获取并使用这些处理后的数据。这种模式支撑了互联网近三十年的蓬勃发展，在给普通用户提供便利的同时，也出现了各种各样的问题，比如：
 泄露用户隐私； 贩卖用户数据； 服务商发布没有底线的广告给不明真相的用户造成不可挽回的损失； 不经协商，随意删除用户发布的内容； 垄断市场和定价； 过度利用用户心理，无节制地占据用户的时间； &mldr;&mldr;  客户端-服务器通信模型如下图：
在为以上问题寻找解决方案时，点对点（即peer to peer）的通信机制逐渐走进了技术先驱们的视野。在互联网早期的时候，点对点通信主要用于文件共享，如音乐共享服务Napster和流媒体下载服务BitTorrent。点对点服务更加广泛的应用，还需要一定的治理机制，来处理资源的版权问题和现实世界的监管，这些不是本文的重点，不做过多地介绍。
点对点通信模型如下图：
在点对点的网络里，所有的节点都是对等的，即任何节点都可以存储和处理数据（作为服务端）；也可以发送待处理的数据给网络中的其它节点，获取经过网络处理后的数据（作为客户端）。通过这样的通信机制，可以保证，
 网络具备开放性，节点可以自由加入和退出； 不依赖单一服务节点，网络的服务更加可靠、高效； 节点运行的程序代码公开可见，规则更加透明。  根据网络中传输的数据和提供服务的不同，点对点应用出现了不同的应用场景，包括文件存储和读取、数据计算、内容共享、数据交易等服务。在开发这些应用的过程中，可能涉及到的技术要点有：
  节点身份，唯一地标识网络中的节点及地址格式；
  发现机制，在没有中心化的协调服务存在的情况下，如何发现新的节点；
  路由，本地节点无法存储网络中所有节点的信息，通过路由算法查找需要的节点；
  多种通信协议比如TCP、UDP、WebSocket、QUIC等等；
  加密和认证，保证消息的可靠和安全；
  NAT穿透，解决NAT后面的内部IP无法访问的难题；
  多路复用以节省资源；
  消息订阅，高效的获取更新而不会给网络造成负担；
  中继，当需要建立通信的两个节点都无法直接被访问，比如都在NAT网络中，需要通过中继节点传递信息；
  &mldr;&mldr;
  以上列出的这些技术要点/需求并不会出现在每个点对点应用里，大多数只会使用其中的一部分功能，尽管如此，还是存在严重地重复造轮子的现象。也有一些应用为了避免重复开发，选择了fork已有开源应用的功能代码，这种方式引入了原有应用的技术债，难于定制和扩展。
复杂多变的网络拓扑和膨胀的应用状态导致了点对点应用的开发、推广和普及都极为困难，出现一个高度模块化的点对点通信开发框架也就不足为奇，也就是接下来我们要介绍的libp2p。
Libp2p 介绍 Libp2p是一个开发点对点应用的框架，它最早源于去中心的文件共享服务IPFS，把网络通信相关的内容抽离并重新设计，形成了现在的libp2p，目前比较成熟的几个语言版本包括js-libp2p、go-libp2p、rust-libp2p，并且定义了一套参考规范，不同语言的实现版本只要符合这一规范，就可以实现互通信。
Libp2p提供的核心功能包括，
 在节点之间建立安全可复用的网络连接； 可验证的节点身份和可连接的地址。  安全可复用的连接 Libp2p支持的底层（传输层）协议包括TCP/IP、UDP、WebSocket、QUIC等，不同语言版本的实现完成度不尽相同。连接的安全性是通过对传输内容进行加密来保证的，节点的身份也会进行相应的验证。"><meta itemprop=datePublished content="2021-02-08T00:00:00+00:00"><meta itemprop=dateModified content="2021-02-08T00:00:00+00:00"><meta itemprop=wordCount content="1104"><meta itemprop=keywords content="Blockchain,Substrate,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Substrate 如何使用 libp2p 进行点对点通信"><meta name=twitter:description content="通过本文，你将了解到，
 点对点通信的特点； libp2p的基本介绍； 以及Substrate如何使用libp2p实现点对点的通信。  点对点通信 在Web2.0时代，绝大多数互联网应用采用了基于TCP/IP的“客户端-服务器”通信架构，在客户端采集数据并发送给服务器，服务器存储和处理数据，客户端进而获取并使用这些处理后的数据。这种模式支撑了互联网近三十年的蓬勃发展，在给普通用户提供便利的同时，也出现了各种各样的问题，比如：
 泄露用户隐私； 贩卖用户数据； 服务商发布没有底线的广告给不明真相的用户造成不可挽回的损失； 不经协商，随意删除用户发布的内容； 垄断市场和定价； 过度利用用户心理，无节制地占据用户的时间； &mldr;&mldr;  客户端-服务器通信模型如下图：
在为以上问题寻找解决方案时，点对点（即peer to peer）的通信机制逐渐走进了技术先驱们的视野。在互联网早期的时候，点对点通信主要用于文件共享，如音乐共享服务Napster和流媒体下载服务BitTorrent。点对点服务更加广泛的应用，还需要一定的治理机制，来处理资源的版权问题和现实世界的监管，这些不是本文的重点，不做过多地介绍。
点对点通信模型如下图：
在点对点的网络里，所有的节点都是对等的，即任何节点都可以存储和处理数据（作为服务端）；也可以发送待处理的数据给网络中的其它节点，获取经过网络处理后的数据（作为客户端）。通过这样的通信机制，可以保证，
 网络具备开放性，节点可以自由加入和退出； 不依赖单一服务节点，网络的服务更加可靠、高效； 节点运行的程序代码公开可见，规则更加透明。  根据网络中传输的数据和提供服务的不同，点对点应用出现了不同的应用场景，包括文件存储和读取、数据计算、内容共享、数据交易等服务。在开发这些应用的过程中，可能涉及到的技术要点有：
  节点身份，唯一地标识网络中的节点及地址格式；
  发现机制，在没有中心化的协调服务存在的情况下，如何发现新的节点；
  路由，本地节点无法存储网络中所有节点的信息，通过路由算法查找需要的节点；
  多种通信协议比如TCP、UDP、WebSocket、QUIC等等；
  加密和认证，保证消息的可靠和安全；
  NAT穿透，解决NAT后面的内部IP无法访问的难题；
  多路复用以节省资源；
  消息订阅，高效的获取更新而不会给网络造成负担；
  中继，当需要建立通信的两个节点都无法直接被访问，比如都在NAT网络中，需要通过中继节点传递信息；
  &mldr;&mldr;
  以上列出的这些技术要点/需求并不会出现在每个点对点应用里，大多数只会使用其中的一部分功能，尽管如此，还是存在严重地重复造轮子的现象。也有一些应用为了避免重复开发，选择了fork已有开源应用的功能代码，这种方式引入了原有应用的技术债，难于定制和扩展。
复杂多变的网络拓扑和膨胀的应用状态导致了点对点应用的开发、推广和普及都极为困难，出现一个高度模块化的点对点通信开发框架也就不足为奇，也就是接下来我们要介绍的libp2p。
Libp2p 介绍 Libp2p是一个开发点对点应用的框架，它最早源于去中心的文件共享服务IPFS，把网络通信相关的内容抽离并重新设计，形成了现在的libp2p，目前比较成熟的几个语言版本包括js-libp2p、go-libp2p、rust-libp2p，并且定义了一套参考规范，不同语言的实现版本只要符合这一规范，就可以实现互通信。
Libp2p提供的核心功能包括，
 在节点之间建立安全可复用的网络连接； 可验证的节点身份和可连接的地址。  安全可复用的连接 Libp2p支持的底层（传输层）协议包括TCP/IP、UDP、WebSocket、QUIC等，不同语言版本的实现完成度不尽相同。连接的安全性是通过对传输内容进行加密来保证的，节点的身份也会进行相应的验证。"><meta name=twitter:site content="@https://twitter.com/kaichaosun"></head><body><nav class=main-nav><a href=https://kaichaosun.github.io/><span class=arrow>←</span>Home</a>
<a href=/about/>About</a>
<a class=cta href=#email-subscribe>Subscribe</a></nav><section id=wrapper><article class=post><header><h1>Substrate 如何使用 libp2p 进行点对点通信</h1><h2 class=subtitle></h2><h2 class=headline>February 8, 2021<br><a href=https://kaichaosun.github.io/tags/blockchain>Blockchain</a>
<a href=https://kaichaosun.github.io/tags/substrate>Substrate</a></h2></header><aside><nav id=TableOfContents><ul><li><a href=#点对点通信>点对点通信</a></li><li><a href=#libp2p-介绍>Libp2p 介绍</a><ul><li><a href=#安全可复用的连接>安全可复用的连接</a></li><li><a href=#节点身份>节点身份</a></li><li><a href=#简单应用>简单应用</a></li></ul></li><li><a href=#substrate-网络层>Substrate 网络层</a></li><li><a href=#总结>总结</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside><section id=post-body><p>通过本文，你将了解到，</p><ul><li>点对点通信的特点；</li><li>libp2p的基本介绍；</li><li>以及Substrate如何使用libp2p实现点对点的通信。</li></ul><h2 id=点对点通信>点对点通信</h2><p>在Web2.0时代，绝大多数互联网应用采用了基于<a href=https://en.wikipedia.org/wiki/Internet_protocol_suite>TCP/IP</a>的“客户端-服务器”通信架构，在客户端采集数据并发送给服务器，服务器存储和处理数据，客户端进而获取并使用这些处理后的数据。这种模式支撑了互联网近三十年的蓬勃发展，在给普通用户提供便利的同时，也出现了各种各样的问题，比如：</p><ul><li>泄露用户隐私；</li><li>贩卖用户数据；</li><li>服务商发布没有底线的广告给不明真相的用户造成不可挽回的损失；</li><li>不经协商，随意删除用户发布的内容；</li><li>垄断市场和定价；</li><li>过度利用用户心理，无节制地占据用户的时间；</li><li>&mldr;&mldr;</li></ul><p><strong>客户端-服务器通信模型如下图：</strong></p><p><img src=/static/libp2p/client_server.png alt=client-server></p><p>在为以上问题寻找解决方案时，点对点（即peer to peer）的通信机制逐渐走进了技术先驱们的视野。在互联网早期的时候，点对点通信主要用于文件共享，如音乐共享服务Napster和流媒体下载服务BitTorrent。点对点服务更加广泛的应用，还需要一定的治理机制，来处理资源的版权问题和现实世界的监管，这些不是本文的重点，不做过多地介绍。</p><p><strong>点对点通信模型如下图：</strong></p><p><img src=/static/libp2p/peer_to_peer.png alt=peer-to-peer></p><p>在点对点的网络里，所有的节点都是对等的，即任何节点都可以存储和处理数据（作为服务端）；也可以发送待处理的数据给网络中的其它节点，获取经过网络处理后的数据（作为客户端）。通过这样的通信机制，可以保证，</p><ul><li>网络具备开放性，节点可以自由加入和退出；</li><li>不依赖单一服务节点，网络的服务更加可靠、高效；</li><li>节点运行的程序代码公开可见，规则更加透明。</li></ul><p>根据网络中传输的数据和提供服务的不同，点对点应用出现了不同的应用场景，包括文件存储和读取、数据计算、内容共享、数据交易等服务。在开发这些应用的过程中，可能涉及到的技术要点有：</p><ul><li><p>节点身份，唯一地标识网络中的节点及地址格式；</p></li><li><p>发现机制，在没有中心化的协调服务存在的情况下，如何发现新的节点；</p></li><li><p>路由，本地节点无法存储网络中所有节点的信息，通过路由算法查找需要的节点；</p></li><li><p>多种通信协议比如TCP、UDP、WebSocket、QUIC等等；</p></li><li><p>加密和认证，保证消息的可靠和安全；</p></li><li><p>NAT穿透，解决NAT后面的内部IP无法访问的难题；</p></li><li><p>多路复用以节省资源；</p></li><li><p>消息订阅，高效的获取更新而不会给网络造成负担；</p></li><li><p>中继，当需要建立通信的两个节点都无法直接被访问，比如都在NAT网络中，需要通过中继节点传递信息；</p></li><li><p>&mldr;&mldr;</p></li></ul><p>以上列出的这些技术要点/需求并不会出现在每个点对点应用里，大多数只会使用其中的一部分功能，尽管如此，还是存在严重地重复造轮子的现象。也有一些应用为了避免重复开发，选择了fork已有开源应用的功能代码，这种方式引入了原有应用的技术债，难于定制和扩展。</p><p>复杂多变的网络拓扑和膨胀的应用状态导致了点对点应用的开发、推广和普及都极为困难，出现一个高度模块化的点对点通信开发框架也就不足为奇，也就是接下来我们要介绍的libp2p。</p><h2 id=libp2p-介绍>Libp2p 介绍</h2><p>Libp2p是一个开发点对点应用的框架，它最早源于去中心的文件共享服务IPFS，把网络通信相关的内容抽离并重新设计，形成了现在的libp2p，目前比较成熟的几个语言版本包括js-libp2p、go-libp2p、rust-libp2p，并且定义了一套参考规范，不同语言的实现版本只要符合这一规范，就可以实现互通信。</p><p>Libp2p提供的核心功能包括，</p><ul><li>在节点之间建立<strong>安全可复用</strong>的网络连接；</li><li>可验证的节点身份和可连接的地址。</li></ul><h3 id=安全可复用的连接>安全可复用的连接</h3><p>Libp2p支持的底层（传输层）协议包括TCP/IP、UDP、WebSocket、QUIC等，不同语言版本的实现完成度不尽相同。连接的安全性是通过对传输内容进行加密来保证的，节点的身份也会进行相应的验证。</p><p>为了提升连接的利用率以及应对复杂的网络场景如各种形式的防火墙和NAT，对建立的底层连接进行多路复用十分有必要，stream就是可实现复用的一种上层连接形式，它可以是双向的，也可以是单向的。</p><p>QUIC协议有内置的安全和复用组件，对于没有此类功能的协议，使用libp2p可以对原始连接进行upgrade，添加所需的安全和可复用的套件，安全套件有<a href=https://docs.rs/libp2p-secio/0.22.0/libp2p_secio/>secio</a>、<a href=https://docs.rs/libp2p/0.28.1/libp2p/noise/index.html>Noise</a>，可复用套件有<a href=https://docs.rs/libp2p-yamux/0.25.0/libp2p_yamux/>yamux</a>和<a href=https://docs.rs/libp2p-mplex/0.22.0/libp2p_mplex/>mplex</a>。</p><p><strong>Upgrade协议的流程如下图：</strong></p><p><img src=/static/libp2p/connection_upgrade.svg alt="connection upgrade"></p><p>在stream里可以传输各种各样的libp2p内置或用户自定义的<a href=https://docs.libp2p.io/concepts/protocols/>应用层协议</a>，这些协议定义了节点间交换信息的方式和内容，比如:</p><ul><li><a href=https://docs.libp2p.io/concepts/protocols/#ping>ping</a>，用来定时检查节点是否在线；</li><li><a href=https://docs.libp2p.io/concepts/protocols/#identify>identity</a>，用于节点间交换信息如节点的public key和网络中的地址；</li><li><a href=https://docs.libp2p.io/concepts/protocols/#kad-dht>kad-dht</a>，基于Kademlia算法的分布哈希表，用于节点间路由；</li><li>&mldr;&mldr;</li></ul><p>以identity协议为例，它的协议id（具有路径格式的字符串）为<code>/ipfs/id/1.0.0</code>，消息的表示和序列化使用的是<a href=https://developers.google.com/protocol-buffers/>protocol buffer</a>，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Identify</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>string</span> protocolVersion <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>string</span> agentVersion <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>bytes</span> publicKey <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>bytes</span> listenAddrs <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>bytes</span> observedAddr <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> protocols <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><h3 id=节点身份>节点身份</h3><p>节点启动时需要提供一个private key（也可以随机生成），主要用于</p><ul><li>将节点双方的公钥通过<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>Diffie-Helman key exchange</a>对消息进行加解密；</li><li>对节点的public key进行哈希，生成PeerId即节点身份。</li></ul><p>Libp2p支持的<a href=https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md#key-types>公钥加密算法</a>包括RSA、Ed25519、Secp256k1等。PeerId的生成采用了<a href=https://docs.libp2p.io/reference/glossary/#multihash>multihashes</a>的形式，即支持多种哈希算法，经过base 58 编码后的格式如<code>QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N</code>。</p><p>将PeerId与<a href=https://docs.libp2p.io/reference/glossary/#multiaddr>multiaddr</a>结合可以用来在网络中定位节点和验证身份，例如IP地址为7.7.7.7、监听在4242端口、拥有上述PeerId的节点的multiaddr（多层次地址）为：</p><pre><code>ip4/7.7.7.7/tcp/4242/p2p/QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N
</code></pre><p>以上只列出了libp2p提供的部分功能，更多内容例如消息订阅、中继、NAT穿透等等可以参考相关<a href=https://docs.libp2p.io/concepts/>文档</a>，使用libp2p开发点对点应用可以解决以上提到的大部分难题和技术点，节约大量的开发时间，增加系统的可维护性和可扩展性。接下来，我们看一下如何使用rust-libp2p实现简单的自定义应用协议。</p><h3 id=简单应用>简单应用</h3><p>这里我们基于rust-libp2p，编写一个简单的点对点应用，可以完成回声（echo）的功能，即其中一个节点发送一个字符串，另一个节点接收该字符串并回复相同的字符，这里我们需要自定义一个应用层的协议<code>EchoProtocol</code>，需要实现libp2p提供的<code>UpgradeInfo</code>接口，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[</span><span style=color:#75715e>derive(Default, Debug, Copy, Clone)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EchoProtocol</span>;

<span style=color:#66d9ef>impl</span> UpgradeInfo <span style=color:#66d9ef>for</span> EchoProtocol {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Info</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>&#39;static [<span style=color:#66d9ef>u8</span>];
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InfoIter</span> <span style=color:#f92672>=</span> iter::Once<span style=color:#f92672>&lt;</span>Self::Info<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>protocol_info</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Self</span>::InfoIter {
        iter::once(<span style=color:#e6db74>b&#34;</span><span style=color:#e6db74>/ipfs/echo/1.0.0</span><span style=color:#e6db74>&#34;</span>)
    }
}
</code></pre></div><p>这里的<code>protocol_info</code>方法返回了协议的名字和格式。接着实现<code>InboundUpgrade</code>和<code>OutboundUpgrade</code>，这两个接口都继承自<code>UpgradeInfo</code>，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> InboundUpgrade<span style=color:#f92672>&lt;</span>NegotiatedSubstream<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> EchoProtocol {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> NegotiatedSubstream;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Void;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>=</span> future::Ready<span style=color:#f92672>&lt;</span>Result<span style=color:#f92672>&lt;</span>Self::Output, Self::Error<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>upgrade_inbound</span>(self, stream: <span style=color:#a6e22e>NegotiatedSubstream</span>, _: <span style=color:#a6e22e>Self</span>::Info) -&gt; <span style=color:#a6e22e>Self</span>::Future {
        future::ok(stream)
    }
}

<span style=color:#66d9ef>impl</span> OutboundUpgrade<span style=color:#f92672>&lt;</span>NegotiatedSubstream<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> EchoProtocol {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> NegotiatedSubstream;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Void;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>=</span> future::Ready<span style=color:#f92672>&lt;</span>Result<span style=color:#f92672>&lt;</span>Self::Output, Self::Error<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>upgrade_outbound</span>(self, stream: <span style=color:#a6e22e>NegotiatedSubstream</span>, _: <span style=color:#a6e22e>Self</span>::Info) -&gt; <span style=color:#a6e22e>Self</span>::Future {
        future::ok(stream)
    }
}
</code></pre></div><p><code>NegotiatedSubstream</code>表示协商好的某个协议将会使用的I/O流。当远端的节点支持当前协议时，调用<code>upgrade_inbound</code>和<code>upgrade_outbound</code>分别在listener和dialer端开启握手信号。</p><p>之后，定义处理连接请求的handler，也就是我们这里的结构体<code>EchoHandler</code>，它保存了处理过程中所使用的状态信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EchoHandler</span> {
    inbound: Option<span style=color:#f92672>&lt;</span>EchoFuture<span style=color:#f92672>&gt;</span>,
    outbound: Option<span style=color:#f92672>&lt;</span>EchoFuture<span style=color:#f92672>&gt;</span>,
    init_echo: <span style=color:#66d9ef>bool</span>,
    already_echo: <span style=color:#66d9ef>bool</span>,
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>EchoFuture</span> <span style=color:#f92672>=</span> BoxFuture<span style=color:#f92672>&lt;</span>&#39;static, Result<span style=color:#f92672>&lt;</span>NegotiatedSubstream, io::Error<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>impl</span> EchoHandler {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(init_echo: <span style=color:#66d9ef>bool</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        EchoHandler {
            inbound: None,
            outbound: None,
            init_echo,
            already_echo: <span style=color:#a6e22e>false</span>,
        }
    }
}
</code></pre></div><p>还需要一个自定义的枚举event枚举类型，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[</span><span style=color:#75715e>derive(Debug)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>EchoHandlerEvent</span> {
    Success,
}
</code></pre></div><p>接着就可以实现libp2p::swarm里所提供的<code>ProtocolsHandler</code>接口了，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> ProtocolsHandler <span style=color:#66d9ef>for</span> EchoHandler {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InEvent</span> <span style=color:#f92672>=</span> Void;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>OutEvent</span> <span style=color:#f92672>=</span> EchoHandlerEvent;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> ReadOneError;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InboundProtocol</span> <span style=color:#f92672>=</span> EchoProtocol;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>OutboundProtocol</span> <span style=color:#f92672>=</span> EchoProtocol;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>OutboundOpenInfo</span> <span style=color:#f92672>=</span> ();
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InboundOpenInfo</span> <span style=color:#f92672>=</span> ();

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>listen_protocol</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>SubstreamProtocol</span><span style=color:#f92672>&lt;</span>EchoProtocol, ()<span style=color:#f92672>&gt;</span> {
        SubstreamProtocol::new(EchoProtocol, ())
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_fully_negotiated_inbound</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, stream: <span style=color:#a6e22e>NegotiatedSubstream</span>, (): ()) {
        <span style=color:#66d9ef>if</span> self.inbound.is_some() {
            panic<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;already have inbound&#34;</span>);
        }
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::inject_fully_negotiated_inbound&#34;</span>);
        self.inbound <span style=color:#f92672>=</span> Some(recv_echo(stream).boxed());
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_fully_negotiated_outbound</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, stream: <span style=color:#a6e22e>NegotiatedSubstream</span>, (): ()) {
        <span style=color:#66d9ef>if</span> self.outbound.is_some() {
            panic<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;already have outbound&#34;</span>);
        }
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::inject_fully_negotiated_outbound&#34;</span>);
        self.outbound <span style=color:#f92672>=</span> Some(send_echo(stream).boxed());
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_event</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _: <span style=color:#a6e22e>Void</span>) {
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_dial_upgrade_error</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _info: (), error: <span style=color:#a6e22e>ProtocolsHandlerUpgrErr</span><span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span>) {
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::inject_dial_upgrade_error: {:?}&#34;</span>, error);
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connection_keep_alive</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>KeepAlive</span> {
        KeepAlive::Yes
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, cx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Context<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;_</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Poll</span><span style=color:#f92672>&lt;</span>
        ProtocolsHandlerEvent<span style=color:#f92672>&lt;</span>
            EchoProtocol,
            (),
            EchoHandlerEvent,
            Self::Error
        <span style=color:#f92672>&gt;</span>
    <span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(fut) <span style=color:#f92672>=</span> self.inbound.as_mut() {
            <span style=color:#66d9ef>match</span> fut.poll_unpin(cx) {
                Poll::Pending <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                    log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::poll, inbound is some but pending...&#34;</span>);
                }
                Poll::Ready(Err(e)) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                    log::error<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::poll, inbound is some but resolve with error: {:?}&#34;</span>, e);
                    self.inbound <span style=color:#f92672>=</span> None;
                    panic<span style=color:#f92672>!</span>();
                }
                Poll::Ready(Ok(stream)) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                    self.inbound <span style=color:#f92672>=</span> Some(recv_echo(stream).boxed());
                    <span style=color:#66d9ef>return</span> Poll::Ready(ProtocolsHandlerEvent::Custom(EchoHandlerEvent::Success))
                }
            }
        }

        <span style=color:#66d9ef>match</span> self.outbound.take() {
            Some(<span style=color:#66d9ef>mut</span> send_echo_future) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                <span style=color:#66d9ef>match</span> send_echo_future.poll_unpin(cx) {
                    Poll::Pending <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                        <span style=color:#75715e>// The future has not yet finished. Make sure
</span><span style=color:#75715e></span>                        <span style=color:#75715e>// to poll it again on the next iteration.
</span><span style=color:#75715e></span>                        self.outbound <span style=color:#f92672>=</span> Some(send_echo_future);
                    },
                    Poll::Ready(Ok(_stream)) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                        <span style=color:#66d9ef>return</span> Poll::Ready(
                            ProtocolsHandlerEvent::Custom(
                                EchoHandlerEvent::Success
                            )
                        )
                    },
                    Poll::Ready(Err(e)) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                        log::error<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;ProtocolsHandler::poll, outbound is some but resolve with error: {:?}&#34;</span>, e);
                        panic<span style=color:#f92672>!</span>();
                    }
                }
            },
            None <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                <span style=color:#66d9ef>if</span> self.init_echo <span style=color:#f92672>&amp;</span><span style=color:#f92672>&amp;</span> <span style=color:#f92672>!</span>self.already_echo {
                    self.already_echo <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
                    <span style=color:#66d9ef>let</span> protocol <span style=color:#f92672>=</span> SubstreamProtocol::new(EchoProtocol, ());
                    <span style=color:#66d9ef>return</span> Poll::Ready(ProtocolsHandlerEvent::OutboundSubstreamRequest {
                        protocol
                    })
                }
            },
        }
        
        Poll::Pending
    }

}
</code></pre></div><p><strong>当节点为dialer</strong>，handler在轮询（<code>ProtocolsHandler::poll()</code>）时，需要返回包含<code>EchoProtocol</code>实例的<code>ProtocolsHandlerEvent::OutboundSubstreamRequest</code>，用于发起并协商连接使用的协议。如果协商成功，调用<code>ProtocolsHandler::inject_fully_negotiated_outbound</code>，在这里我们将handler保存的outbount状态由None更新为<code>Some(send_echo(stream).boxed())</code>，其中<code>send_echo</code>接收协商好的IO stream，无错误发生时返回该stream。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>const</span> ECHO_SIZE: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>;

<span style=color:#66d9ef>pub</span> async <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>send_echo</span><span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>mut</span> stream: <span style=color:#a6e22e>S</span>) -&gt; <span style=color:#a6e22e>io</span>::Result<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>where</span>
    S: <span style=color:#a6e22e>AsyncRead</span> <span style=color:#f92672>+</span> AsyncWrite <span style=color:#f92672>+</span> Unpin
{
    <span style=color:#75715e>// mxinden: A bit of a hack. Likely nicer to do somewhere else.
</span><span style=color:#75715e></span>    futures_timer::Delay::new(std::time::Duration::from_secs(<span style=color:#ae81ff>3</span>)).await;

    <span style=color:#66d9ef>let</span> payload <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world!&#34;</span>;
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;send_echo, preparing send payload: {:?}, in bytes: {:?}&#34;</span>, payload, payload.as_bytes());
    stream.write_all(payload.as_bytes()).await<span style=color:#f92672>?</span>;
    stream.flush().await<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> recv_payload <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>; ECHO_SIZE];
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;send_echo, awaiting echo for {:?}&#34;</span>, payload);
    
    stream.read_exact(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> recv_payload).await<span style=color:#f92672>?</span>;
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;send_echo, received echo: {:?}&#34;</span>, <span style=color:#66d9ef>str</span>::from_utf8(<span style=color:#f92672>&amp;</span>recv_payload));
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>str</span>::from_utf8(<span style=color:#f92672>&amp;</span>recv_payload) <span style=color:#f92672>=</span><span style=color:#f92672>=</span> Ok(payload) {
        Ok(stream)
    } <span style=color:#66d9ef>else</span> {
        Err(io::Error::new(io::ErrorKind::InvalidData, <span style=color:#e6db74>&#34;Echo payload mismatch&#34;</span>))
    }
}
</code></pre></div><p>我们接着看<code>ProtocolsHandler::poll</code>里的实现，当outbound为Some，send_echo返回的future轮询的结果为<code>Poll::Pending</code>时，更新outbound为<code>self.outbound = Some(send_echo_future)</code>，保证下次轮询时依然有效，当结果为<code>Poll::Ready</code>时返回相应的事件信息。</p><p><strong>当节点为listener</strong>，连接中出现新的请求流时，自动调用<code>ProtocolsHandler::listen_protocol</code>返回一个<code>InboundUpgrade</code>的实例来协商流使用的协议。协商成功之后，调用<code>inject_fully_negotiated_inbound</code>，其中一个参数为协商好的stream，在该方法内，将handler的inbound属性状态更新为<code>Some(recv_echo(stream).boxed())</code>，<code>recv_echo</code>方法的实现为，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> async <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recv_echo</span><span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>mut</span> stream: <span style=color:#a6e22e>S</span>) -&gt; <span style=color:#a6e22e>io</span>::Result<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>where</span>
    S: <span style=color:#a6e22e>AsyncRead</span> <span style=color:#f92672>+</span> AsyncWrite <span style=color:#f92672>+</span> Unpin
{
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> payload <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>; ECHO_SIZE];
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;recv_echo, waiting for echo...&#34;</span>);
    stream.read_exact(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> payload).await<span style=color:#f92672>?</span>;
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;recv_echo, receive echo request for payload: {:?}&#34;</span>, payload);
    stream.write_all(<span style=color:#f92672>&amp;</span>payload).await<span style=color:#f92672>?</span>;
    stream.flush().await<span style=color:#f92672>?</span>;
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;recv_echo, echo back successfully for payload: {:?}&#34;</span>, payload);
    Ok(stream)
}
</code></pre></div><p>这里泛型<code>S</code>需要满足<a href=https://docs.rs/futures-io/0.3.12/futures_io/>futures_io</a>提供的<code>AsyncRead</code>和<code>AsyncWrite</code>约束。</p><p>点对点网络就像一个蜂群（Swarm），而蜂群的整体行为是由单一个体的行为所组成的，单一个体的行为由一系列的规则所制定，此类的规则可以组合使用，在rust-libp2p中，规定的定义需要实现<code>NetworkBehaviour</code>接口，这里我们先定义一个结构体，对规则的状态进行保存。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EchoBehaviour</span> {
    events: <span style=color:#a6e22e>VecDeque</span><span style=color:#f92672>&lt;</span>EchoBehaviourEvent<span style=color:#f92672>&gt;</span>,
    config: <span style=color:#a6e22e>EchoBehaviourConfig</span>,
}

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EchoBehaviourConfig</span> {
    init_echo: <span style=color:#66d9ef>bool</span>,
}

<span style=color:#66d9ef>impl</span> EchoBehaviour {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(config: <span style=color:#a6e22e>EchoBehaviourConfig</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        EchoBehaviour {
            events: <span style=color:#a6e22e>VecDeque</span>::new(),
            config,
        }
    }
}

<span style=color:#75715e>#[</span><span style=color:#75715e>derive(Debug)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EchoBehaviourEvent</span> {
    <span style=color:#66d9ef>pub</span> peer: <span style=color:#a6e22e>PeerId</span>,
    <span style=color:#66d9ef>pub</span> result: <span style=color:#a6e22e>EchoHandlerEvent</span>,
}
</code></pre></div><p>本结构体包含了与Swarm沟通的消息<code>events</code>，行为定义所需要的初始配置。接着，就可以实现<code>NetworkBehaviour</code>接口了，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> NetworkBehaviour <span style=color:#66d9ef>for</span> EchoBehaviour {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProtocolsHandler</span> <span style=color:#f92672>=</span> EchoHandler;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>OutEvent</span> <span style=color:#f92672>=</span> EchoBehaviourEvent;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new_handler</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>Self</span>::ProtocolsHandler {
        EchoHandler::new(self.config.init_echo)
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>addresses_of_peer</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _peer_id: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PeerId</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Multiaddr<span style=color:#f92672>&gt;</span> {
        Vec::new()
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_connected</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PeerId</span>) {
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;NetworkBehaviour::inject_connected&#34;</span>);
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_disconnected</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PeerId</span>) {
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;NetworkBehaviour::inject_disconnected&#34;</span>);
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>inject_event</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, peer: <span style=color:#a6e22e>PeerId</span>, _: <span style=color:#a6e22e>ConnectionId</span>, result: <span style=color:#a6e22e>EchoHandlerEvent</span>) {
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;NetworkBehaviour::inject_event&#34;</span>);
        self.events.push_front(EchoBehaviourEvent { peer, result })
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Context<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;_</span><span style=color:#f92672>&gt;</span>, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>impl</span> PollParameters)
        -&gt; <span style=color:#a6e22e>Poll</span><span style=color:#f92672>&lt;</span>NetworkBehaviourAction<span style=color:#f92672>&lt;</span>Void, EchoBehaviourEvent<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span>
    {
        log::debug<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;NetworkBehaviour::poll, events: {:?}&#34;</span>, self.events);
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(e) <span style=color:#f92672>=</span> self.events.pop_back() {
            Poll::Ready(NetworkBehaviourAction::GenerateEvent(e))
        } <span style=color:#66d9ef>else</span> {
            Poll::Pending
        }
    }
}
</code></pre></div><p>当连接建立或者尝试去呼叫节点时会调用<code>new_handler</code>，返回我们之前定义的handler即<code>EchoHandler</code>，作为该连接的后台处理线程，behaviour和handler通过消息传递的机制进行通信，<code>inject_event</code>可以把handler的消息传给behaviour，behaviour在poll的时候返回<code>SendEvent</code>将消息传递给handler。</p><p>到这里，我们已经完成了一个简单的echo点对点通信协议，现在我们看一下main函数里如何使用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span>dyn Error<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span> {
    env_logger::init();

    <span style=color:#75715e>// create a random peerid.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> id_keys <span style=color:#f92672>=</span> identity::Keypair::generate_ed25519();
    <span style=color:#66d9ef>let</span> peer_id <span style=color:#f92672>=</span> PeerId::from(id_keys.public());
    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Local peer id: {:?}&#34;</span>, peer_id);

    <span style=color:#75715e>// create a transport.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> transport <span style=color:#f92672>=</span> libp2p::build_development_transport(id_keys)<span style=color:#f92672>?</span>;
    
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> behaviour_config <span style=color:#f92672>=</span> EchoBehaviourConfig { init_echo: <span style=color:#a6e22e>false</span> };
    <span style=color:#75715e>// get the multi-address of remote peer given as the second cli argument.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> std::env::args().nth(<span style=color:#ae81ff>1</span>);
    <span style=color:#75715e>// if remote peer exists, the peer can initialize an echo request.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> target.is_some() {
        behaviour_config <span style=color:#f92672>=</span> EchoBehaviourConfig { init_echo: <span style=color:#a6e22e>true</span> };
    }

    <span style=color:#75715e>// create a echo network behaviour.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> behaviour <span style=color:#f92672>=</span> EchoBehaviour::new(behaviour_config);
    
    <span style=color:#75715e>// create a swarm that establishes connections through the given transport
</span><span style=color:#75715e></span>    <span style=color:#75715e>// and applies the echo behaviour on each connection.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> swarm <span style=color:#f92672>=</span> Swarm::new(transport, behaviour, peer_id);

    <span style=color:#75715e>// if the remote peer exists, dial it.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(addr) <span style=color:#f92672>=</span> target {
        <span style=color:#66d9ef>let</span> remote <span style=color:#f92672>=</span> addr.parse()<span style=color:#f92672>?</span>;

        Swarm::dial_addr(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> swarm, remote)<span style=color:#f92672>?</span>;
        log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Dialed {}&#34;</span>, addr)
    }
    

    <span style=color:#75715e>// Tell the swarm to listen on all interfaces and a random, OS-assigned port.
</span><span style=color:#75715e></span>    Swarm::listen_on(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> swarm, <span style=color:#e6db74>&#34;/ip4/0.0.0.0/tcp/0&#34;</span>.parse()<span style=color:#f92672>?</span>)<span style=color:#f92672>?</span>;

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> listening <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
    task::block_on(future::poll_fn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>cx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Context<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;_</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>|</span> {
        <span style=color:#66d9ef>loop</span> {
            <span style=color:#66d9ef>match</span> swarm.poll_next_unpin(cx) {
                Poll::Ready(Some(event)) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Get event: {:?}&#34;</span>, event),
                Poll::Ready(None) <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Swam poll next ready none&#34;</span>);
                    <span style=color:#66d9ef>return</span> Poll::Ready(())
                },
                Poll::Pending <span style=color:#f92672>=</span><span style=color:#f92672>&gt;</span> {
                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>listening {
                        <span style=color:#66d9ef>for</span> addr <span style=color:#66d9ef>in</span> Swarm::listeners(<span style=color:#f92672>&amp;</span>swarm) {
                            log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Listening on {}&#34;</span>, addr);
                            listening <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
                        }
                    }
                    <span style=color:#66d9ef>return</span> Poll::Pending
                }
            }
        }
    }));

    Ok(())
}
</code></pre></div><p>代码的简单说明如下：</p><ul><li>通过<code>Keypair::generate_ed25519</code>生成用于节点间通信加密的密钥，其中的公钥可以派生出节点的<code>PeerId</code>。</li><li><code>libp2p::build_development_transport</code>构建了开发常用的传输层，支持TCP/IP、WebSocket，使用noise协议作为加密层，yamux和mplex多路复用协议。</li><li>解析传入参数，如果包含呼叫的节点信息，则是dialer（客户端），将构造behaviour的初始参数<code>init_echo</code>设置为true。</li><li>使用上面构造的传输层、behaviour、节点id，调用<code>Swarm::new(transport, behaviour, peer_id)</code>构造模拟网络的swarm。</li><li>当节点为dialer时，呼叫传入的远端节点<code>Swarm::dial_addr(&mut swarm, remote)?</code>，将该节点加入swarm节点池中。</li><li>对swarm进行轮询<code>swarm.poll_next_unpin(cx)</code>，如果有behaviour触发的消息，处理对应的消息。</li></ul><p><strong>小结</strong>，libp2p对点对点通信进行了高度的抽象，在开始接触这些概念时，容易摸不着头脑，需要不断去熟悉划分的层次和常用的协议；rust-libp2p的实现，针对libp2p定义的层次和协议，封装出了不同的接口，在开发自定义协议的同时，需要深入去了解这些抽象的接口及接口间通信的方式。总体来说，点对点通信开发的难度比传统的客户端-服务器通信形式高很多，libp2p的设计在于弥合这其中的一些痛点，但也还有很长的路要走，应用开发者需要更多地了解底层的机制才能更好的开发应用协议。目前，使用libp2p的应用包括IPFS，Substrate/Polkadot，Libra，Ethereum 2.0等等，接下来我们来了解下Substrate如何使用的libp2p。</p><h2 id=substrate-网络层>Substrate 网络层</h2><p>区块链网络是由去中心（或者说是点对点）的节点所组成，节点之间通过网络连接传递消息，Substrate作为通用的区块链开发框架，它的网络层使用了rust-libp2p，可以很容易地使用、扩展一系列的通信协议，例如：</p><ul><li>传输层支持TCP/IP（地址格式为<code>/ip4/1.2.3.4/tcp/5</code>）、WebSocket（地址格式为<code>/ip4/1.2.3.4/tcp/5/ws</code>）、DNS（地址格式<code>/dns/example.com/tcp/5</code>或<code>/dns/example.com/tcp/5/ws</code>），以及对应的IPv6格式；</li><li>在传输层之上应用了加密协议 <a href=https://docs.rs/libp2p/0.34.0/libp2p/noise/index.html>Noise</a>；</li><li>支持多路复用协议<a href=https://github.com/hashicorp/yamux/blob/master/spec.md>Yamux</a>和<a href=https://github.com/libp2p/specs/tree/master/mplex>Mplex</a>，其中mplex会逐步废弃；</li><li>使用libp2p标准的<a href=https://docs.rs/libp2p/0.34.0/libp2p/ping/index.html>ping协议</a>（<code>/ipfs/ping/1.0.0</code>），周期性的检查节点间的网络连接是否还活着，如果检查失败会断开连接；</li><li>使用libp2p标准的<a href=https://docs.rs/libp2p/0.34.0/libp2p/identify/index.html>id协议</a>（<code>/ipfs/id/1.0.0</code>），节点之间通过该协议周期性地交换节点各自的信息；</li><li>libp2p标准的<a href=https://docs.rs/libp2p/0.34.0/libp2p/kad/index.html>Kademlia协议</a>（<code>/&lt;protocol_id>/kad</code>），执行Kademlia random walk查询，其中protocol_id可以用来区分不同的链，在Substrate chain spec中进行定义；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#substreams>sync协议</a>（<code>/&lt;protocol-id>/sync/2</code>），用来同步区块信息，请求和返回结果的数据格式定义在<a href=https://github.com/paritytech/substrate/blob/master/client/network/src/schema/api.v1.proto>api.v1.proto</a>文件中；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#substreams>light协议</a>（<code>/&lt;protocol-id>/light/2</code>），轻客户端用此协议同步链上的状态信息，数据格式定义在<a href=https://github.com/paritytech/substrate/blob/master/client/network/src/schema/light.v1.proto>light.v1.proto</a>文件中；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#substreams>transactions协议</a>（<code>/&lt;protocol-id>/transactions/1</code>），用来广播节点接收到的交易信息，它的格式是交易集合的SCALE编码结果；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#substreams>区块广播协议</a>（<code>/&lt;protocol-id>/block-announces/1</code>），当节点产出或者接收到区块时，将此区块向其它节点进行广播；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#substreams>gossip协议</a>（<code>/paritytech/grandpa/1</code>），GRANDPA用来通知其它节点相关的投票信息；</li><li>自定义的<a href=https://crates.parity.io/sc_network/index.html#the-legacy-substrate-substream>Substrate legacy协议</a>（<code>/substrate/&lt;protocol-id>/&lt;version></code>），是一个即将被弃用的协议，它也可以同步、广播区块信息，处理轻客户端请求，Gossiping（被GRANDPA使用）等等。</li></ul><p>结合以上的底层和应用层通信协议，Substrate的节点之间可以通过三种发现机制建立起连接，</p><ul><li>启动节点（bootstrap nodes），它的地址和PeerId都是固定的，适用于网络的冷启动和某节点刚加入网络时，通过启动节点进入到网络中；</li><li><a href=https://github.com/libp2p/specs/blob/master/discovery/mdns.md>mDNS</a>，在本地网络通过广播UDP数据包，如果有节点响应，则可以建立起连接；</li><li>Kademlia random walk，当连接建立后，当前节点可以通过<code>FIND_NODE</code> 请求远端节点，获取远端节点关于当前网络中节点组成的视角。</li></ul><p>以上的协议共同构成了Substrate的通用网络层，而这一网络层的使用是通过<code>NetworkWorker</code>和<code>NetworkService</code>结构体来实现的，在node template节点程序中的使用示例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> (network, network_status_sinks, system_rpc_tx, network_starter) <span style=color:#f92672>=</span>
		sc_service::build_network(sc_service::BuildNetworkParams {
			config: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>config</span>,
			client: <span style=color:#a6e22e>client</span>.clone(),
			transaction_pool: <span style=color:#a6e22e>transaction_pool</span>.clone(),
			spawn_handle: <span style=color:#a6e22e>task_manager</span>.spawn_handle(),
			import_queue,
			on_demand: None,
			block_announce_validator_builder: None,
		})<span style=color:#f92672>?</span>;
</code></pre></div><h2 id=总结>总结</h2><p>去中心的通信模型为互联网应用开辟了新的范式，也带来了相当大的挑战，libp2p规范的出现，逐步减轻了开发者在开发点对点应用所遇到的痛点。Substrate借助libp2p的优良特性，在区块链这一细分的去中心应用领域，可以很方便的让普通开发者无需过多的关注底层的通信机制，就可以完成复杂的自定义区块链应用。</p><h2 id=reference>Reference</h2><p><a href=https://en.wikipedia.org/wiki/Peer-to-peer>Wiki: Peer-to-peer</a></p><p><a href=https://www.infoq.com/presentations/blockchain-libp2p/>How to Leverage Libp2p for Blockchain Applications</a></p><p><a href=https://crates.parity.io/sc_network/index.html>Substrate Crate sc_network</a></p><p><a href=https://github.com/auditdrivencrypto/secure-channel/blob/master/prior-art.md#ipfss-secure-channel>IPFS secure channel</a></p><p><a href=https://github.com/libp2p/specs>Libp2p specification</a></p><p><a href=https://blog.textile.io/a-primer-on-libp2p/>Textile's primer on libp2p</a></p></section></article><footer id=post-meta class=clearfix><a href=https://twitter.com/kaichaosun><img class=avatar src=https://kaichaosun.github.io/images/avatar.png><div><span class=dark>Kaichao Sun</span>
<span>Mark it down</span></div></a><section id=sharing><a class=twitter href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkaichaosun.github.io%2fpost%2fsubstrate_network_libp2p%2f - Substrate%20%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%20libp2p%20%e8%bf%9b%e8%a1%8c%e7%82%b9%e5%af%b9%e7%82%b9%e9%80%9a%e4%bf%a1 by @kaichaosun"><span class=icon-twitter>tweet</span></a>
<a class=facebook href=# onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;"><span class=icon-facebook-rect>Share</span></a></section></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"whisperd"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><ul id=post-list class="archive readmore"><iframe src=https://kaichao.substack.com/embed id=email-subscribe width=100% height=320 style="border:1px solid #eee;background:#fff;margin-top:60px" frameborder=0 scrolling=no></iframe><h3>Read more</h3><li><a href=https://kaichaosun.github.io/post/lbcd_multi_user/>Setup Multi-User Environment for lbcd<aside class=dates>Feb 29 2024</aside></a></li><li><a href=https://kaichaosun.github.io/post/how_did_we_do_wrong/>关于新冠，我们做错了什么？<aside class=dates>Apr 14 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/understand_decentralization/>如何理解去中心<aside class=dates>Feb 23 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/build_team/>Build in Public：创业团队的重要性<aside class=dates>Feb 11 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_history/>Substrate 技术演进<aside class=dates>Jan 22 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/metaverse/>元宇宙会不会把我们从一条人变成一条狗？<aside class=dates>Jan 21 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_read_source_code/>阅读Substrate源码的方法<aside class=dates>Jan 6 2021</aside></a></li><li><a href=https://kaichaosun.github.io/post/learn_substrate/>如何学习Substrate<aside class=dates>Jul 20 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_launch_public_testnet/>Substrate 部署公开测试网络<aside class=dates>Jul 17 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/how_to_blockchain/>如何学习区块链技术<aside class=dates>Apr 30 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/kusama_governance/>Kusama系列：如何进行链上治理<aside class=dates>Apr 16 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_node_template_guide/>Substrate代码导读：node-template<aside class=dates>Apr 2 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/trie/>理解Substrate数据存储的底层实现Merkle Patricia Trie<aside class=dates>Mar 17 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_transaction_weight_and_fees/>Substrate 区块链应用的交易费用设计<aside class=dates>Feb 21 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_storage_data_type/>Substrate存储数据类型概览<aside class=dates>Jan 19 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/coin_flip_test_and_ui/>抛硬币游戏(二)：编写测试和UI<aside class=dates>Oct 3 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_metadata/>Substrate Runtime Metadata<aside class=dates>Sep 7 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_coin_flip/>Substrate应用 - 抛硬币游戏(一)<aside class=dates>Aug 5 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_module_struct/>Substrate Module Struct<aside class=dates>Jul 30 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_blockchain_setup/>使用Substrate搭建你的第一条区块链<aside class=dates>May 28 2019</aside></a></li></ul><footer id=footer><div id=social><a class=symbol href=https://github.com/kaichaosun><i class="fa fa-github"></i></a><a class=symbol href=https://t.me/kaichaosun><i class="fa fa-telegram"></i></a><a class=symbol href=https://twitter.com/kaichaosun><i class="fa fa-twitter"></i></a></div><p class=small>© Copyright 2024 Kaichao Sun</p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://kaichaosun.github.io/js/main.js></script><script src=https://kaichaosun.github.io/js/highlight.js></script><script src=https://kaichaosun.github.io/js/fix-toc.js></script><script>hljs.initHighlightingOnLoad();</script><script data-ad-client=ca-pub-2513693433628672 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-128168145-1','auto');ga('send','pageview');}</script></body></html>