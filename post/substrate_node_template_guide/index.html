<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kaichao Sun"><meta name=description content="kaichao's blog"><meta name=generator content="Hugo 0.62.2"><title>Substrate代码导读：node-template</title><link rel="shortcut icon" href=https://kaichaosun.github.io/images/favicon.ico><link rel=stylesheet href=https://kaichaosun.github.io/css/style.css><link rel=stylesheet href=https://kaichaosun.github.io/css/highlight.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css><meta property="og:title" content="Substrate代码导读：node-template"><meta property="og:description" content="通过本文，你会了解到，
 Substrate node-template的组成部分，及各部分的功能简介 参数如何配置  Substrate作为一个标准的区块链开发框架，不仅提供了必备的底层公共组件（如数据库、共识、P2P、交易池）和通用的runtime模块（如资产相关的balances，治理相关的democracy等），还提供了将各个功能组件连接起来的节点模板程序（node-template）和节点程序（node）。本文主要介绍node-template中各个代码块的功能。
文件目录 在使用类Unix操作系统的情况下，进入node-template文件目录，执行tree -I target命令，获取详细的文件信息如下：
 这里我们忽略了target文件目录下的内容，来较少干扰性的输出。
 workspace cargo.toml node-template是一个标准的Rust workspace项目，当项目比较复杂时，使用workspace可以清晰地管理组件库（library）和可执行程序（binary）。在项目根目录的cargo.toml文件里有：
[workspace] members = [ 'node', 'pallets/template', 'runtime', ] 这个workspace的成员有node、pallets/template、runtime，其中node是可执行程序，在对应的src/main.rs文件内拥有一个可执行的main函数入口；pallets/template和runtime是组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。
细心的同学会注意到cargo.toml里还有下面两行配置:
[profile.release] panic = 'unwind' 它和catch_unwind一起使用可以捕获某个线程内panic抛出的异常，常用的场景有：
 在其它编程语言中嵌入Rust； 自定义线程处理的逻辑； 测试框架，因为测试用例可以panic，但是不能中断测试的运行。  具体请参考Controlling panics with std::panic。
workspace build.rs 自定义的构建脚本放置在项目的build.rs文件内，可以在编译构建项目之前，让Cargo去编译和执行该脚本，使用场景有：
 编译、连接第三方的非Rust代码； 构建之前的代码生成功能。  node-template根目录下的build.rs的具体功能，参考下面的注释，
use vergen::{ConstantsFlags, generate_cargo_keys}; const ERROR_MSG: &str = &#34;Failed to generate metadata files&#34;; fn main() { // 使用vergen生成环境变量，供项目中的env!宏获取  // 这里设置了VERGEN_SHA_SHORT为Git最新的commit id的缩写 	generate_cargo_keys(ConstantsFlags::SHA_SHORT)."><meta property="og:type" content="article"><meta property="og:url" content="https://kaichaosun.github.io/post/substrate_node_template_guide/"><meta property="article:published_time" content="2020-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-02T00:00:00+00:00"><meta itemprop=name content="Substrate代码导读：node-template"><meta itemprop=description content="通过本文，你会了解到，
 Substrate node-template的组成部分，及各部分的功能简介 参数如何配置  Substrate作为一个标准的区块链开发框架，不仅提供了必备的底层公共组件（如数据库、共识、P2P、交易池）和通用的runtime模块（如资产相关的balances，治理相关的democracy等），还提供了将各个功能组件连接起来的节点模板程序（node-template）和节点程序（node）。本文主要介绍node-template中各个代码块的功能。
文件目录 在使用类Unix操作系统的情况下，进入node-template文件目录，执行tree -I target命令，获取详细的文件信息如下：
 这里我们忽略了target文件目录下的内容，来较少干扰性的输出。
 workspace cargo.toml node-template是一个标准的Rust workspace项目，当项目比较复杂时，使用workspace可以清晰地管理组件库（library）和可执行程序（binary）。在项目根目录的cargo.toml文件里有：
[workspace] members = [ 'node', 'pallets/template', 'runtime', ] 这个workspace的成员有node、pallets/template、runtime，其中node是可执行程序，在对应的src/main.rs文件内拥有一个可执行的main函数入口；pallets/template和runtime是组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。
细心的同学会注意到cargo.toml里还有下面两行配置:
[profile.release] panic = 'unwind' 它和catch_unwind一起使用可以捕获某个线程内panic抛出的异常，常用的场景有：
 在其它编程语言中嵌入Rust； 自定义线程处理的逻辑； 测试框架，因为测试用例可以panic，但是不能中断测试的运行。  具体请参考Controlling panics with std::panic。
workspace build.rs 自定义的构建脚本放置在项目的build.rs文件内，可以在编译构建项目之前，让Cargo去编译和执行该脚本，使用场景有：
 编译、连接第三方的非Rust代码； 构建之前的代码生成功能。  node-template根目录下的build.rs的具体功能，参考下面的注释，
use vergen::{ConstantsFlags, generate_cargo_keys}; const ERROR_MSG: &str = &#34;Failed to generate metadata files&#34;; fn main() { // 使用vergen生成环境变量，供项目中的env!宏获取  // 这里设置了VERGEN_SHA_SHORT为Git最新的commit id的缩写 	generate_cargo_keys(ConstantsFlags::SHA_SHORT)."><meta itemprop=datePublished content="2020-04-02T00:00:00+00:00"><meta itemprop=dateModified content="2020-04-02T00:00:00+00:00"><meta itemprop=wordCount content="372"><meta itemprop=keywords content="Blockchain,Substrate,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Substrate代码导读：node-template"><meta name=twitter:description content="通过本文，你会了解到，
 Substrate node-template的组成部分，及各部分的功能简介 参数如何配置  Substrate作为一个标准的区块链开发框架，不仅提供了必备的底层公共组件（如数据库、共识、P2P、交易池）和通用的runtime模块（如资产相关的balances，治理相关的democracy等），还提供了将各个功能组件连接起来的节点模板程序（node-template）和节点程序（node）。本文主要介绍node-template中各个代码块的功能。
文件目录 在使用类Unix操作系统的情况下，进入node-template文件目录，执行tree -I target命令，获取详细的文件信息如下：
 这里我们忽略了target文件目录下的内容，来较少干扰性的输出。
 workspace cargo.toml node-template是一个标准的Rust workspace项目，当项目比较复杂时，使用workspace可以清晰地管理组件库（library）和可执行程序（binary）。在项目根目录的cargo.toml文件里有：
[workspace] members = [ 'node', 'pallets/template', 'runtime', ] 这个workspace的成员有node、pallets/template、runtime，其中node是可执行程序，在对应的src/main.rs文件内拥有一个可执行的main函数入口；pallets/template和runtime是组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。
细心的同学会注意到cargo.toml里还有下面两行配置:
[profile.release] panic = 'unwind' 它和catch_unwind一起使用可以捕获某个线程内panic抛出的异常，常用的场景有：
 在其它编程语言中嵌入Rust； 自定义线程处理的逻辑； 测试框架，因为测试用例可以panic，但是不能中断测试的运行。  具体请参考Controlling panics with std::panic。
workspace build.rs 自定义的构建脚本放置在项目的build.rs文件内，可以在编译构建项目之前，让Cargo去编译和执行该脚本，使用场景有：
 编译、连接第三方的非Rust代码； 构建之前的代码生成功能。  node-template根目录下的build.rs的具体功能，参考下面的注释，
use vergen::{ConstantsFlags, generate_cargo_keys}; const ERROR_MSG: &str = &#34;Failed to generate metadata files&#34;; fn main() { // 使用vergen生成环境变量，供项目中的env!宏获取  // 这里设置了VERGEN_SHA_SHORT为Git最新的commit id的缩写 	generate_cargo_keys(ConstantsFlags::SHA_SHORT)."><meta name=twitter:site content="@https://twitter.com/kaichaosun"></head><body><nav class=main-nav><a href=https://kaichaosun.github.io/><span class=arrow>←</span>Home</a>
<a href=/about/>About</a>
<a class=cta href=#email-subscribe>Subscribe</a></nav><section id=wrapper><article class=post><header><h1>Substrate代码导读：node-template</h1><h2 class=subtitle></h2><h2 class=headline>April 2, 2020<br><a href=https://kaichaosun.github.io/tags/blockchain>Blockchain</a>
<a href=https://kaichaosun.github.io/tags/substrate>Substrate</a></h2></header><aside><nav id=TableOfContents><ul><li><a href=#文件目录>文件目录</a></li><li><a href=#workspace-cargotoml>workspace cargo.toml</a></li><li><a href=#workspace-buildrs>workspace build.rs</a></li><li><a href=#scriptsinitsh>scripts/init.sh</a></li><li><a href=#pallets>pallets</a></li><li><a href=#runtime>runtime</a></li><li><a href=#node>node</a></li><li><a href=#总结>总结</a></li><li><a href=#更多>更多</a></li></ul></nav></aside><section id=post-body><p>通过本文，你会了解到，</p><ul><li>Substrate node-template的组成部分，及各部分的功能简介</li><li>参数如何配置</li></ul><p>Substrate作为一个标准的区块链开发框架，不仅提供了必备的底层公共组件（如数据库、共识、P2P、交易池）和通用的runtime模块（如资产相关的balances，治理相关的democracy等），还提供了将各个功能组件连接起来的节点模板程序（<a href=https://github.com/paritytech/substrate/tree/master/bin/node-template>node-template</a>）和节点程序（<a href=https://github.com/paritytech/substrate/tree/master/bin/node>node</a>）。本文主要介绍node-template中各个代码块的功能。</p><h2 id=文件目录>文件目录</h2><p>在使用类Unix操作系统的情况下，进入node-template文件目录，执行<code>tree -I target</code>命令，获取详细的文件信息如下：</p><p><img src=/static/node-template/node_template_dir.png alt=node_template_tree_info></p><blockquote><p>这里我们忽略了target文件目录下的内容，来较少干扰性的输出。</p></blockquote><h2 id=workspace-cargotoml>workspace cargo.toml</h2><p>node-template是一个标准的<a href=https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html>Rust workspace</a>项目，当项目比较复杂时，使用workspace可以清晰地管理组件库（library）和可执行程序（binary）。在项目根目录的cargo.toml文件里有：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>workspace</span>]
<span style=color:#a6e22e>members</span> = [
    <span style=color:#e6db74>&#39;node&#39;</span>,
    <span style=color:#e6db74>&#39;pallets/template&#39;</span>,
    <span style=color:#e6db74>&#39;runtime&#39;</span>,
]
</code></pre></div><p>这个workspace的成员有node、pallets/template、runtime，其中node是可执行程序，在对应的src/main.rs文件内拥有一个可执行的main函数入口；pallets/template和runtime是组件库，在src/lib.rs定义了可被外部使用的函数和数据结构。</p><p>细心的同学会注意到cargo.toml里还有下面两行配置:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>profile</span>.<span style=color:#a6e22e>release</span>]
<span style=color:#a6e22e>panic</span> = <span style=color:#e6db74>&#39;unwind&#39;</span>
</code></pre></div><p>它和<code>catch_unwind</code>一起使用可以捕获某个线程内panic抛出的异常，常用的场景有：</p><ul><li>在其它编程语言中嵌入Rust；</li><li>自定义线程处理的逻辑；</li><li>测试框架，因为测试用例可以panic，但是不能中断测试的运行。</li></ul><p>具体请参考<a href=https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/controlling-panics-with-std-panic.html>Controlling panics with <code>std::panic</code></a>。</p><h2 id=workspace-buildrs>workspace build.rs</h2><p>自定义的构建脚本放置在项目的build.rs文件内，可以在编译构建项目之前，让Cargo去编译和执行该脚本，使用场景有：</p><ul><li>编译、连接第三方的非Rust代码；</li><li>构建之前的代码生成功能。</li></ul><p>node-template根目录下的build.rs的具体功能，参考下面的注释，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> vergen::{ConstantsFlags, generate_cargo_keys};

<span style=color:#66d9ef>const</span> ERROR_MSG: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Failed to generate metadata files&#34;</span>;

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#75715e>// 使用vergen生成环境变量，供项目中的env!宏获取
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 这里设置了VERGEN_SHA_SHORT为Git最新的commit id的缩写
</span><span style=color:#75715e></span>	generate_cargo_keys(ConstantsFlags::SHA_SHORT).expect(ERROR_MSG);

  <span style=color:#75715e>// 当.git/HEAD文件改变即切换Git分支时，重新执行这一脚本
</span><span style=color:#75715e></span>	build_script_utils::rerun_if_git_head_changed();
}
</code></pre></div><h2 id=scriptsinitsh>scripts/init.sh</h2><p>初始化编译环境，包括升级Rust的版本，包括nightly和stable两个<a href=https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains>发布渠道</a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>rustup update nightly
rustup update stable
</code></pre></div><p>并且添加构建WebAssembly的支持工具：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre></div><p>定期执行本脚本，可以解决一些常见的编译问题如某个依赖安装失败。</p><h2 id=pallets>pallets</h2><p>包含了自定义的runtime模块，默认只有一个template模块，以此模块为例：</p><p><strong><a href=https://doc.rust-lang.org/cargo/reference/manifest.html>cargo.toml</a>包含</strong>：</p><ul><li><p>package的基本信息如name，version，authors等。</p></li><li><p>package所依赖的第三方库，以<code>frame-support</code>为例，来源是Github上该代码仓库的某个commit id，并将default-features设置为false（即不使用默认的feature进行编译）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>dependencies</span>.<span style=color:#a6e22e>frame</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#a6e22e>support</span>]
<span style=color:#a6e22e>default</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#a6e22e>features</span> = <span style=color:#66d9ef>false</span>
<span style=color:#a6e22e>git</span> = <span style=color:#e6db74>&#39;https://github.com/paritytech/substrate.git&#39;</span>
<span style=color:#a6e22e>rev</span> = <span style=color:#e6db74>&#39;013c1ee167354a08283fb69915fda56a62fee943&#39;</span>
<span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#39;2.0.0-alpha.3&#39;</span>
</code></pre></div></li><li><p>通过<a href=https://doc.rust-lang.org/cargo/reference/features.html>feature</a>进行条件编译，当使用Cargo进行构建时，下面的配置表示默认使用std feature，当编译依赖库如frame-support也默认使用std feature。这样的配置保证了runtime模块既可以编译为Native执行版本（使用std feature），也可以编译为Wasm执行版本（使用no_std feature，并由<a href=https://github.com/paritytech/substrate/tree/master/utils/wasm-builder>WasmBuilder</a>进行编译，后面会详细介绍）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>features</span>]
<span style=color:#a6e22e>default</span> = [<span style=color:#e6db74>&#39;std&#39;</span>]
<span style=color:#a6e22e>std</span> = [
    <span style=color:#e6db74>&#39;codec/std&#39;</span>,
    <span style=color:#e6db74>&#39;frame-support/std&#39;</span>,
    <span style=color:#e6db74>&#39;safe-mix/std&#39;</span>,
    <span style=color:#e6db74>&#39;system/std&#39;</span>,
]
</code></pre></div></li></ul><blockquote><p>说明：Substrate为了保证应用的安全和稳定，对runtime有意地添加了一个约束，也就是在runtime代码里只能使用Rust的核心库及一些辅助库，而不能使用<a href=https://doc.rust-lang.org/std/>标准库</a>。使用标准库会导致Wasm执行版本编译失败。</p></blockquote><p><strong>src/lib.rs</strong> 是runtime模块的具体功能实现：</p><ul><li><p><code>#![cfg_attr(not(feature = "std"), no_std)]</code>表示编译时如果feature不是std，那么必须是no_std。</p></li><li><p>mock和test模块只在运行测试时进行编译；</p></li><li><p>定义了模块的接口，继承自system模块的接口，并添加了一个关联类型Event，这个Event类型可以转换成system模块下的Event，也可以由当前的template模块定义的的Event转换而来；</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Trait: <span style=color:#a6e22e>system</span>::Trait {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span>: From<span style=color:#f92672>&lt;</span>Event<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>+</span> Into<span style=color:#f92672>&lt;</span><span style=color:#f92672>&lt;</span>Self <span style=color:#66d9ef>as</span> system::Trait<span style=color:#f92672>&gt;</span>::Event<span style=color:#f92672>&gt;</span>;
}
</code></pre></div></li><li><p>使用decl_storage宏定义模块的存储单元；</p></li><li><p>使用decl_event宏定义模块可能触发的事件；</p></li><li><p>使用decl_error宏定义模块可以返回的错误种类；</p></li><li><p>最后通过decl_module宏定义了本模块的核心逻辑即可调用函数（Dispatchable Call），并初始化Error类型和Event的默认触发方式。</p></li></ul><p><strong>src/mock.rs</strong> 是为测试用例服务的，</p><ul><li><p><code>pub struct Test;</code>创建了一个测试用的runtime结构体；</p></li><li><p>通过<code>impl_outer_origin</code>宏为runtime构造了一个Origin类型，用来标识交易的来源；</p></li><li><p>通过<code>parameter_types</code>宏生成一些后面功能模块所需的满足<code>Get</code>接口的数据类型；</p></li><li><p>为runtime实现各个功能模块接口，这里使用了大量的<code>()</code>来mock不关心的数据类型；</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> Trait <span style=color:#66d9ef>for</span> Test {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#f92672>=</span> ();
}
</code></pre></div></li><li><p><code>pub type TemplateModule = Module&lt;Test>;</code>定义别名，使测试代码更简洁；</p></li><li><p>定义了函数<code>new_test_ext</code>来初始化GenesisConfig，并返回一个基于HashMap的TestExternalities，用于存储的读写和其它扩展操作。</p></li></ul><p><strong>src/tests.rs</strong> 包含了所有的测试用例，</p><ul><li>引入mock数据和断言；</li><li>通过<code>#[test]</code>来标识测试函数；</li><li>调用<code>new_test_ext</code>，并通过<code>execute_with</code>执行closure内的代码；</li><li>调用template模块的可调用函数，并返回执行结果<code>TemplateModule::do_something(Origin::signed(1)</code>。</li><li><code>assert_ok</code>断言结果是Ok，<code>assert_eq</code>断言结果等于预期，<code>assert_noop</code>断言结果为Error并且不修改链上存储状态。</li></ul><h2 id=runtime>runtime</h2><p><strong>cargo.toml</strong> 除了上面提到的某个pallet对应的cargo.toml里的类似内容外，还添加了，</p><ul><li><p>构建脚本即build.rs的依赖<code>wasm-builder-runner</code>；</p></li><li><p>Substrate内置和开发者自定义的runtime模块（也叫做pallet）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>dependencies</span>.<span style=color:#a6e22e>sudo</span>]
<span style=color:#a6e22e>default</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#a6e22e>features</span> = <span style=color:#66d9ef>false</span>
<span style=color:#a6e22e>git</span> = <span style=color:#e6db74>&#39;https://github.com/paritytech/substrate.git&#39;</span>
<span style=color:#a6e22e>package</span> = <span style=color:#e6db74>&#39;pallet-sudo&#39;</span>
<span style=color:#a6e22e>rev</span> = <span style=color:#e6db74>&#39;013c1ee167354a08283fb69915fda56a62fee943&#39;</span>
<span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#39;2.0.0-alpha.3&#39;</span>
  
[<span style=color:#a6e22e>dependencies</span>.<span style=color:#a6e22e>template</span>]
<span style=color:#a6e22e>default</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#a6e22e>features</span> = <span style=color:#66d9ef>false</span>
<span style=color:#a6e22e>package</span> = <span style=color:#e6db74>&#39;pallet-template&#39;</span>
<span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#39;../pallets/template&#39;</span>
<span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#39;2.0.0-alpha.3&#39;</span>
</code></pre></div></li></ul><p><strong>build.rs</strong> 使用<code>wasm-builder-runner</code>将当前的runtime项目编译为Wasm，编译后的文件位于<code>target/release/wbuild/node-template-runtime/node_template_runtime.compact.wasm</code>。</p><p><strong>src/lib.rs</strong> 就是构造我们链上runtime的入口，</p><ul><li><p><code>#![cfg_attr(not(feature = "std"), no_std)]</code>表示编译时如果feature不是std，那么必须是no_std；</p></li><li><p><code>#![recursion_limit="256"]</code>用来设置编译期间可能出现无限递归操作（如宏展开）的最大阈值，默认是128，这里我们提高到256，来满足<code>consturct_runtime</code>宏的需求；</p></li><li><p>使用std featue编译时，将生成的Wasm二进制内容通过常量的方式引入到当前runtime代码中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[</span><span style=color:#75715e>cfg(feature = </span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>std</span><span style=color:#e6db74>&#34;</span><span style=color:#75715e>)</span><span style=color:#75715e>]</span>
include<span style=color:#f92672>!</span>(concat<span style=color:#f92672>!</span>(env<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;OUT_DIR&#34;</span>), <span style=color:#e6db74>&#34;/wasm_binary.rs&#34;</span>));
</code></pre></div></li><li><p>引入依赖的模块，以及为了下游模块方便调用而暴露上游模块的部分函数和数据类型，如<code>pub use balances::Call as BalancesCall</code>；</p></li><li><p>引入template模块 <code>pub use template</code>；</p></li><li><p>给runtime所需的基础类型起别名，原则是和模块中的associate type名称一致，如<code>pub type BlockNumber = u32</code>；</p></li><li><p>opaque模块封装了一些用于CLI初始化时的类型，这些类型和runtime的具体信息；</p></li><li><p>指定了runtime版本信息，当runtime协议修改之后，需要将<code>spec_version</code>加1；<code>impl_version</code>是协议的实现版本，用来表示节点运行的代码是不同的，仅当非共识相关的优化发生时才可能修改这个值；<code>RUNTIME_API_VERSIONS</code>包含已实现的runtime api的所有版本信息，由<code>impl_runtime_apis</code>宏生成，后面会进一步介绍。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> VERSION: <span style=color:#a6e22e>RuntimeVersion</span> <span style=color:#f92672>=</span> RuntimeVersion {
    spec_name: <span style=color:#a6e22e>create_runtime_str</span><span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;node-template&#34;</span>),
    impl_name: <span style=color:#a6e22e>create_runtime_str</span><span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;node-template&#34;</span>),
    authoring_version: <span style=color:#ae81ff>1</span>,
    spec_version: <span style=color:#ae81ff>1</span>,
    impl_version: <span style=color:#ae81ff>1</span>,
    apis: <span style=color:#a6e22e>RUNTIME_API_VERSIONS</span>,
};
</code></pre></div></li><li><p>定义区块时间相关的常量，如<code>pub const MILLISECS_PER_BLOCK: u64 = 6000</code>，即每个区块是6秒，可以根据需要修改配置；</p></li><li><p>指定当前的NativeVersion，在执行交易时会把NativeVersion和链上的RuntimeVersion进行比较，如果不一致，通常情况下会使用Wasm执行交易。</p></li><li><p>使用<code>parameter_types</code>宏生成一些后面功能模块所需的满足<code>Get</code>接口的数据类型；</p></li><li><p>为runtime的实现各个功能模块的接口，runtime由<code>construct_runtime</code>宏生成，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> template::Trait <span style=color:#66d9ef>for</span> Runtime {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#f92672>=</span> Event;
}
</code></pre></div></li><li><p><code>construct_runtime</code>宏根据名称（如<code>TemplateModule</code>）和所用的模块内的组件（如<code>template::{Module, Call, Storage, Event&lt;T>}</code>）来构造runtime，从而使模块中的信息通过metadata暴露出来，并且使该模块在runtime中可用。构造时，是按照顺序加载初始存储的，所以当B模块依赖A模块时，应当将A模块放在B之前。</p></li><li><p>通过<code>impl_runtime_apis</code>宏实现runtime api定义的接口，这些接口需要通过<code>decl_runtime_apis</code>宏进行定义。</p></li></ul><h2 id=node>node</h2><p><strong>cargo.toml</strong> 使用<code>[[bin]]</code>表示这个包是可执行的，通过<code>build-dependencies</code>引入编译时的依赖，在build.rs中使用，其它内容在前面的章节已经介绍过了。</p><p><strong>build.rs</strong> 的内容和workspace根目录下的build.rs相同。</p><p><strong>src/main.rs</strong> 是node-template编译成可执行程序的入口文件，</p><ul><li><p><code>#![warn(missing_docs)]</code>在编译时，当模块缺少文档时会打印warnning；</p></li><li><p>引入了当前目录下的其它代码模块，如<code>mod chain_spec</code>；</p></li><li><p><code>#[macro_use]</code>会加载引入的模块下的所有宏；</p></li><li><p>main函数是程序的入口，它返回一个<a href=https://github.com/paritytech/substrate/blob/master/client/cli/src/error.rs#L20>自定义的Result类型</a>，在函数内首先构造了一个<code>VersionInfo</code>的结构体，用来保存可执行程序的版本信息，其中<code>VERGEN_SHA_SHORT</code>是在编译时由build.rs产生的，然后执行command模块提供的run函数。</p></li></ul><p><strong>src/command.rs</strong> 提供了main所需的run函数，</p><ul><li>通过<code>from_args</code>解析命令行的执行参数，返回一个<code>Cli</code>结构体，具体参考下面src/cli.rs的内容；</li><li>创建一个默认的<a href=https://substrate.dev/rustdocs/v2.0.0-alpha.3/sc_service/config/struct.Configuration.html>Substrate服务配置</a>，这些服务包含启动线程运行网络、客户端和交易池等；</li><li>如果返回的<code>Cli</code>实例里存在子命令，则执行子命令，执行子命令时，<ul><li>首先进行初始化，如设置panic的异常处理机制，日志等；</li><li>通过<code>chain_spec::load_spec</code>获取chain的配置，来更新前面构造的Substrate服务配置；</li><li>调用子命令的<code>run</code>函数来执行该命令，run函数依赖src/service.rs模块里的<code>new_full_start</code>宏来返回ServiceBuilder，包含了构建Substrate服务的多种组件。</li></ul></li><li>如果返回的<code>Cli</code>实例里没有子命令，则执行当前命令，<ul><li>首先初始化，和子命令的初始化功能一样；</li><li>更新Substrate服务配置，比子命令的更新操作更全面，配置的所有属性都会更新；</li><li>调用<code>run</code>来启动节点，需要传入全节点客户端的服务实例和轻节点客户端的服务实例，根据服务配置中的节点角色进行选择，启动完成后，保持运行直到接收到退出信号<code>SIGINT</code>（即Ctrl+C）。</li></ul></li></ul><p><strong>src/cli.rs</strong> 借助<a href=https://github.com/TeXitoi/structopt>StructOpt</a>库将命令行参数解析为Cli结构体，包含：</p><ul><li>可选的子命令，如<code>purge-chain</code>清空本地存储，<code>build-spec</code>创建一个spec.json的初始文件，<code>revert</code>回滚链上状态等；</li><li>命令行参数，如<code>--validator</code>开启验证人模式，<code>--light</code>以轻客户端方式运行，<code>--ws-port 9944</code>指定WebSocket监听的TCP端口，等等。编译node-template之后，可以通过<code>./target/release/node-template -h</code>获取所有可用的子命令和参数，及其帮助信息。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[</span><span style=color:#75715e>derive(Debug, StructOpt)</span><span style=color:#75715e>]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cli</span> {
	<span style=color:#75715e>#[</span><span style=color:#75715e>structopt(subcommand)</span><span style=color:#75715e>]</span>
	<span style=color:#66d9ef>pub</span> subcommand: Option<span style=color:#f92672>&lt;</span>Subcommand<span style=color:#f92672>&gt;</span>,

	<span style=color:#75715e>#[</span><span style=color:#75715e>structopt(flatten)</span><span style=color:#75715e>]</span>
	<span style=color:#66d9ef>pub</span> run: <span style=color:#a6e22e>RunCmd</span>,
}
</code></pre></div><p><strong>chain_spec.rs</strong> 构造了<code>ChainSpec</code>，它定义了链的可用配置，用来构造初始区块，</p><ul><li>node-template提供了两种模式，通过命令行参数<code>--dev</code>指定开发者网络（Development），只有Alice是验证人；<code>--local</code>指定本地测试网络（LocalTestnet），Alice和Bob是验证人；</li><li>调用<code>ChainSpec::from_genesis</code>创建硬编码的ChainSpec；</li><li>定义了<code>testnet_genesis</code>函数，传入验证人列表、root账户、存有余额的账户列表，构造出GenesisConfig。</li></ul><p><strong>service.rs</strong> 提供了构造Substrate服务的帮助方法，</p><ul><li>使用<code>native_executor_instance</code>宏定义了一个结构体<code>Executor</code>，并且实现了<code>NativeExecutionDispatch</code>接口，即可以通过函数名称来调用该函数；</li><li><code>new_full_start</code>宏构建了一个ServiceBuilder，用来构造全节点服务，过程如下：<ul><li>调用<code>with_select_chain </code>设置链的生成策略，也就是当链出现分叉的时候，选择哪个链继续工作，这里使用最长链原则；</li><li>调用<code>with_transaction_pool</code> 设置交易池类型，这里使用BasicPool；</li><li>调用<code>with_import_queue</code> 设置了导入区块所需的队列，这里使用BasicQueue，可以顺序地导入block。</li></ul></li><li>使用<code>new_full</code>构建一个全节点服务，<ul><li>使用<code>new_full_start</code>宏构建了一个ServiceBuilder；</li><li>调用<code>with_finality_proof_provider</code>设置使用何种策略提供最终性验证；</li><li>调用<code>build</code>构建真正的<a href=https://substrate.dev/rustdocs/v2.0.0-alpha.3/sc_service/struct.Service.html>Substrate Service</a>；</li><li>如果是验证人并且不是哨兵模式，调用service的<code>spawn_essential_task</code>函数，启动用于生成区块的后台任务，使用的是Aura算法；</li><li>如果GRANDPA功能没有关闭，调用<code>spawn_essential_task</code>开启后台运行的投票任务。</li></ul></li><li>使用<code>new_light</code>构建一个轻节点服务，<ul><li>调用<code>with_select_chain </code>设置跟随最长链；</li><li>调用<code>with_transaction_pool</code>设置BasicPool交易池类型;</li><li>调用<code>with_import_queue_and_fprb</code>设置区块导入时所用的队列，以及用来构建最终性验证请求的<code>FinalityProofRequestBuilder</code>；</li><li>调用<code>with_finality_proof_provider</code>设置使用何种策略提供最终性验证；</li><li>调用<code>build</code>构建真正的<a href=https://substrate.dev/rustdocs/v2.0.0-alpha.3/sc_service/struct.Service.html>Substrate Service</a>。</li></ul></li></ul><h2 id=总结>总结</h2><p>通过本文，我相信你已经对node-template项目的代码有了比较深入的了解，现在你可以试着调节runtime代码中的一些配置参数如出块时间，自定义一条区块链。</p><h2 id=更多>更多</h2><p>Substrate官方文档：<a href=https://substrate.dev/>https://substrate.dev/</a></p><p>Parity介绍：<a href=https://www.parity.io/>https://www.parity.io/</a></p><p>Substrate源码：<a href=https://github.com/paritytech/substrate>https://github.com/paritytech/substrate</a></p><p>Polkadot源码：<a href=https://github.com/paritytech/polkadot>https://github.com/paritytech/polkadot</a></p></section></article><footer id=post-meta class=clearfix><a href=https://twitter.com/kaichaosun><img class=avatar src=https://kaichaosun.github.io/images/avatar.png><div><span class=dark>Kaichao Sun</span>
<span>Mark it down</span></div></a><section id=sharing><a class=twitter href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkaichaosun.github.io%2fpost%2fsubstrate_node_template_guide%2f - Substrate%e4%bb%a3%e7%a0%81%e5%af%bc%e8%af%bb%ef%bc%9anode-template by @kaichaosun"><span class=icon-twitter>tweet</span></a>
<a class=facebook href=# onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;"><span class=icon-facebook-rect>Share</span></a></section></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"whisperd"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><ul id=post-list class="archive readmore"><iframe src=https://kaichao.substack.com/embed id=email-subscribe width=100% height=320 style="border:1px solid #eee;background:#fff;margin-top:60px" frameborder=0 scrolling=no></iframe><h3>Read more</h3><li><a href=https://kaichaosun.github.io/post/lbcd_multi_user/>Setup Multi-User Environment for lbcd<aside class=dates>Feb 29 2024</aside></a></li><li><a href=https://kaichaosun.github.io/post/how_did_we_do_wrong/>关于新冠，我们做错了什么？<aside class=dates>Apr 14 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/understand_decentralization/>如何理解去中心<aside class=dates>Feb 23 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/build_team/>Build in Public：创业团队的重要性<aside class=dates>Feb 11 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_history/>Substrate 技术演进<aside class=dates>Jan 22 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/metaverse/>元宇宙会不会把我们从一条人变成一条狗？<aside class=dates>Jan 21 2022</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_network_libp2p/>Substrate 如何使用 libp2p 进行点对点通信<aside class=dates>Feb 8 2021</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_read_source_code/>阅读Substrate源码的方法<aside class=dates>Jan 6 2021</aside></a></li><li><a href=https://kaichaosun.github.io/post/learn_substrate/>如何学习Substrate<aside class=dates>Jul 20 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_launch_public_testnet/>Substrate 部署公开测试网络<aside class=dates>Jul 17 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/how_to_blockchain/>如何学习区块链技术<aside class=dates>Apr 30 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/kusama_governance/>Kusama系列：如何进行链上治理<aside class=dates>Apr 16 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/trie/>理解Substrate数据存储的底层实现Merkle Patricia Trie<aside class=dates>Mar 17 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_transaction_weight_and_fees/>Substrate 区块链应用的交易费用设计<aside class=dates>Feb 21 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_storage_data_type/>Substrate存储数据类型概览<aside class=dates>Jan 19 2020</aside></a></li><li><a href=https://kaichaosun.github.io/post/coin_flip_test_and_ui/>抛硬币游戏(二)：编写测试和UI<aside class=dates>Oct 3 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_metadata/>Substrate Runtime Metadata<aside class=dates>Sep 7 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_coin_flip/>Substrate应用 - 抛硬币游戏(一)<aside class=dates>Aug 5 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_module_struct/>Substrate Module Struct<aside class=dates>Jul 30 2019</aside></a></li><li><a href=https://kaichaosun.github.io/post/substrate_blockchain_setup/>使用Substrate搭建你的第一条区块链<aside class=dates>May 28 2019</aside></a></li></ul><footer id=footer><div id=social><a class=symbol href=https://github.com/kaichaosun><i class="fa fa-github"></i></a><a class=symbol href=https://t.me/kaichaosun><i class="fa fa-telegram"></i></a><a class=symbol href=https://twitter.com/kaichaosun><i class="fa fa-twitter"></i></a></div><p class=small>© Copyright 2024 Kaichao Sun</p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://kaichaosun.github.io/js/main.js></script><script src=https://kaichaosun.github.io/js/highlight.js></script><script src=https://kaichaosun.github.io/js/fix-toc.js></script><script>hljs.initHighlightingOnLoad();</script><script data-ad-client=ca-pub-2513693433628672 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-128168145-1','auto');ga('send','pageview');}</script></body></html>