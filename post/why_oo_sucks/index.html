<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kaichao Sun"><meta name=description content="kaichao's blog"><meta name=generator content="Hugo 0.62.2"><title>Why OO Sucks</title><link rel="shortcut icon" href=https://kaichaosun.github.io/images/favicon.ico><link rel=stylesheet href=https://kaichaosun.github.io/css/style.css><link rel=stylesheet href=https://kaichaosun.github.io/css/highlight.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css><meta property="og:title" content="Why OO Sucks"><meta property="og:description" content="原文为英文，由 Joe Armstrong 撰写。我的翻译如下。
当我第一次接触OOP(Object Oriented Programming, 面向对象编程)概念的时候，就感到十分怀疑，但是又不知道为什么，就是感觉&#34;不对&rdquo;。当OOP变得非常流行(下面会解释原因)，批判OOP就像&rdquo;在教堂诅咒&ldquo;一样会被排斥。OO逐渐成为了主流编程语言必须要有的特性。
随着Erlang变得流行，我们经常被问到&#34;Erlang是面向对象的吗？&#34;。真正的答案当然是&#34;不支持&rdquo;，但是我们并不敢对外这么说，为此我们发明了一系列巧妙的方式来回答这个问题，给大家营造一种Erlang在某种程度上是OO，但又不真的是OO(如果仔细听我们说的，看小字印刷的内容就知道了)。
这个时候，我想到了 IBM 那时的老板在巴黎第七届IEEE Logic 编程会议时, 被问及IBM Prolog为什么添加了一系列面向对象的扩展，回答是：
 我们的客户希望使用面向对象的Prolog，所以我们就创造了面向对象的Prolog。
 我当时的想法是&#34;这么简单粗暴的回答，没有任何良心上的不安，没有灵魂深处的拷问，也没有想过这是不是正确的事情 …&mldr;&rdquo;
面向对象为什么糟糕 对面向对象的主要反对理由可以回归到面向对象的基本理念，在这里我会简述其中一些基本理念以及我对它们的反对意见。
反对1. 数据结构和函数不应该捆绑在一起 对象将数据和函数绑定在了一个不可分割的单元。我认为这是一个根本性的错误，因为函数和数据属于完全不同的两个世界。为什么这么说呢？
 函数的作用是处理一些事情。它们有输入和输出。输入和输出是数据，数据可以被函数所改变。在大多数编程语言里，函数由一系列指令所构建：&ldquo;先干这个，之后再干那个……&#34;。为了理解函数，你必须理解这些事情以何种顺序完成。(在支持延迟计算的函数式编程语言中，这个限制并不严格。) 而数据就静静的待在那里。它们什么都不做。它们本身是声明性的。&ldquo;理解&#34;数据远比&#34;理解&#34;函数简单的多。  为了便于理解，函数通常被当作&#34;黑盒&#34;处理，用来把输入转换成输出。如果我理解了输入和输出，那么我就理解了这个函数。但这不意味着我可以写出这个函数。
通常可以认为函数是计算系统的一些&#34;部件&rdquo;，它们的职责是从一种数据结构转换成另一种数据结构。
函数和数据是完全不同的两类&#34;动物&rdquo;，强行把它们锁在同一个&#34;笼子&#34;里，本身就是不正确的。
反对2. 一切事物都必须是一个对象 想想**&ldquo;时间&rdquo;**，在面向对象编程语言中，&ldquo;时间&#34;必须是一个对象。(在Smalltalk中，甚至&#34;3&#34;都是一个对象)。但是在非面向对象的语言中，&ldquo;时间&#34;只是某种数据类型的实例。例如，在Erlang中，存在各种各样的时间表示形式，通过使用类型声明可以清晰明确地进行指定，如：
-deftype day() = 1..31. -deftype month() = 1..12. -deftype year() = int(). -deftype hour() = 1..24. -deftype minute() = 1..60. -deftype second() = 1..60. -deftype abstime() = {abstime,year(),month(),day(),hour(),min(),sec()}. -deftype hms() = {hms,hour(),min(),sec()}. … 注意：上面的定义不属于任意特定的对象。它们是通用的，系统中的任意的函数（译者：这里的函数并不指代已有签名的那些函数，而是对函数的概指）都可以处理以上数据结构所表示的时间。"><meta property="og:type" content="article"><meta property="og:url" content="https://kaichaosun.github.io/post/why_oo_sucks/"><meta property="article:published_time" content="2019-04-25T00:00:00+00:00"><meta property="article:modified_time" content="2019-04-25T00:00:00+00:00"><meta itemprop=name content="Why OO Sucks"><meta itemprop=description content="原文为英文，由 Joe Armstrong 撰写。我的翻译如下。
当我第一次接触OOP(Object Oriented Programming, 面向对象编程)概念的时候，就感到十分怀疑，但是又不知道为什么，就是感觉&#34;不对&rdquo;。当OOP变得非常流行(下面会解释原因)，批判OOP就像&rdquo;在教堂诅咒&ldquo;一样会被排斥。OO逐渐成为了主流编程语言必须要有的特性。
随着Erlang变得流行，我们经常被问到&#34;Erlang是面向对象的吗？&#34;。真正的答案当然是&#34;不支持&rdquo;，但是我们并不敢对外这么说，为此我们发明了一系列巧妙的方式来回答这个问题，给大家营造一种Erlang在某种程度上是OO，但又不真的是OO(如果仔细听我们说的，看小字印刷的内容就知道了)。
这个时候，我想到了 IBM 那时的老板在巴黎第七届IEEE Logic 编程会议时, 被问及IBM Prolog为什么添加了一系列面向对象的扩展，回答是：
 我们的客户希望使用面向对象的Prolog，所以我们就创造了面向对象的Prolog。
 我当时的想法是&#34;这么简单粗暴的回答，没有任何良心上的不安，没有灵魂深处的拷问，也没有想过这是不是正确的事情 …&mldr;&rdquo;
面向对象为什么糟糕 对面向对象的主要反对理由可以回归到面向对象的基本理念，在这里我会简述其中一些基本理念以及我对它们的反对意见。
反对1. 数据结构和函数不应该捆绑在一起 对象将数据和函数绑定在了一个不可分割的单元。我认为这是一个根本性的错误，因为函数和数据属于完全不同的两个世界。为什么这么说呢？
 函数的作用是处理一些事情。它们有输入和输出。输入和输出是数据，数据可以被函数所改变。在大多数编程语言里，函数由一系列指令所构建：&ldquo;先干这个，之后再干那个……&#34;。为了理解函数，你必须理解这些事情以何种顺序完成。(在支持延迟计算的函数式编程语言中，这个限制并不严格。) 而数据就静静的待在那里。它们什么都不做。它们本身是声明性的。&ldquo;理解&#34;数据远比&#34;理解&#34;函数简单的多。  为了便于理解，函数通常被当作&#34;黑盒&#34;处理，用来把输入转换成输出。如果我理解了输入和输出，那么我就理解了这个函数。但这不意味着我可以写出这个函数。
通常可以认为函数是计算系统的一些&#34;部件&rdquo;，它们的职责是从一种数据结构转换成另一种数据结构。
函数和数据是完全不同的两类&#34;动物&rdquo;，强行把它们锁在同一个&#34;笼子&#34;里，本身就是不正确的。
反对2. 一切事物都必须是一个对象 想想**&ldquo;时间&rdquo;**，在面向对象编程语言中，&ldquo;时间&#34;必须是一个对象。(在Smalltalk中，甚至&#34;3&#34;都是一个对象)。但是在非面向对象的语言中，&ldquo;时间&#34;只是某种数据类型的实例。例如，在Erlang中，存在各种各样的时间表示形式，通过使用类型声明可以清晰明确地进行指定，如：
-deftype day() = 1..31. -deftype month() = 1..12. -deftype year() = int(). -deftype hour() = 1..24. -deftype minute() = 1..60. -deftype second() = 1..60. -deftype abstime() = {abstime,year(),month(),day(),hour(),min(),sec()}. -deftype hms() = {hms,hour(),min(),sec()}. … 注意：上面的定义不属于任意特定的对象。它们是通用的，系统中的任意的函数（译者：这里的函数并不指代已有签名的那些函数，而是对函数的概指）都可以处理以上数据结构所表示的时间。"><meta itemprop=datePublished content="2019-04-25T00:00:00+00:00"><meta itemprop=dateModified content="2019-04-25T00:00:00+00:00"><meta itemprop=wordCount content="111"><meta itemprop=keywords content="FP,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why OO Sucks"><meta name=twitter:description content="原文为英文，由 Joe Armstrong 撰写。我的翻译如下。
当我第一次接触OOP(Object Oriented Programming, 面向对象编程)概念的时候，就感到十分怀疑，但是又不知道为什么，就是感觉&#34;不对&rdquo;。当OOP变得非常流行(下面会解释原因)，批判OOP就像&rdquo;在教堂诅咒&ldquo;一样会被排斥。OO逐渐成为了主流编程语言必须要有的特性。
随着Erlang变得流行，我们经常被问到&#34;Erlang是面向对象的吗？&#34;。真正的答案当然是&#34;不支持&rdquo;，但是我们并不敢对外这么说，为此我们发明了一系列巧妙的方式来回答这个问题，给大家营造一种Erlang在某种程度上是OO，但又不真的是OO(如果仔细听我们说的，看小字印刷的内容就知道了)。
这个时候，我想到了 IBM 那时的老板在巴黎第七届IEEE Logic 编程会议时, 被问及IBM Prolog为什么添加了一系列面向对象的扩展，回答是：
 我们的客户希望使用面向对象的Prolog，所以我们就创造了面向对象的Prolog。
 我当时的想法是&#34;这么简单粗暴的回答，没有任何良心上的不安，没有灵魂深处的拷问，也没有想过这是不是正确的事情 …&mldr;&rdquo;
面向对象为什么糟糕 对面向对象的主要反对理由可以回归到面向对象的基本理念，在这里我会简述其中一些基本理念以及我对它们的反对意见。
反对1. 数据结构和函数不应该捆绑在一起 对象将数据和函数绑定在了一个不可分割的单元。我认为这是一个根本性的错误，因为函数和数据属于完全不同的两个世界。为什么这么说呢？
 函数的作用是处理一些事情。它们有输入和输出。输入和输出是数据，数据可以被函数所改变。在大多数编程语言里，函数由一系列指令所构建：&ldquo;先干这个，之后再干那个……&#34;。为了理解函数，你必须理解这些事情以何种顺序完成。(在支持延迟计算的函数式编程语言中，这个限制并不严格。) 而数据就静静的待在那里。它们什么都不做。它们本身是声明性的。&ldquo;理解&#34;数据远比&#34;理解&#34;函数简单的多。  为了便于理解，函数通常被当作&#34;黑盒&#34;处理，用来把输入转换成输出。如果我理解了输入和输出，那么我就理解了这个函数。但这不意味着我可以写出这个函数。
通常可以认为函数是计算系统的一些&#34;部件&rdquo;，它们的职责是从一种数据结构转换成另一种数据结构。
函数和数据是完全不同的两类&#34;动物&rdquo;，强行把它们锁在同一个&#34;笼子&#34;里，本身就是不正确的。
反对2. 一切事物都必须是一个对象 想想**&ldquo;时间&rdquo;**，在面向对象编程语言中，&ldquo;时间&#34;必须是一个对象。(在Smalltalk中，甚至&#34;3&#34;都是一个对象)。但是在非面向对象的语言中，&ldquo;时间&#34;只是某种数据类型的实例。例如，在Erlang中，存在各种各样的时间表示形式，通过使用类型声明可以清晰明确地进行指定，如：
-deftype day() = 1..31. -deftype month() = 1..12. -deftype year() = int(). -deftype hour() = 1..24. -deftype minute() = 1..60. -deftype second() = 1..60. -deftype abstime() = {abstime,year(),month(),day(),hour(),min(),sec()}. -deftype hms() = {hms,hour(),min(),sec()}. … 注意：上面的定义不属于任意特定的对象。它们是通用的，系统中的任意的函数（译者：这里的函数并不指代已有签名的那些函数，而是对函数的概指）都可以处理以上数据结构所表示的时间。"><meta name=twitter:site content="@https://twitter.com/kaichaosun"></head><body><nav class=main-nav><a href=https://kaichaosun.github.io/><span class=arrow>←</span>Home</a>
<a href=/about/>About</a>
<a class=cta href=#email-subscribe>Subscribe</a></nav><section id=wrapper><article class=post><header><h1>Why OO Sucks</h1><h2 class=subtitle></h2><h2 class=headline>April 25, 2019<br><a href=https://kaichaosun.github.io/tags/fp>FP</a></h2></header><aside><nav id=TableOfContents><ul><li><a href=#面向对象为什么糟糕>面向对象为什么糟糕</a><ul><li><a href=#反对1-数据结构和函数不应该捆绑在一起>反对1. 数据结构和函数不应该捆绑在一起</a></li><li><a href=#反对2-一切事物都必须是一个对象>反对2. 一切事物都必须是一个对象</a></li><li><a href=#反对3-在oop中到处都是数据类型定义>反对3. 在OOP中，到处都是数据类型定义</a></li><li><a href=#反对4-对象存在私有状态>反对4. 对象存在私有状态</a></li></ul></li><li><a href=#面向对象为什么流行>面向对象为什么流行？</a></li><li><a href=#参见-the-third-manifesto>参见 The Third Manifesto</a></li></ul></nav></aside><section id=post-body><p>原文为英文，由 <a href=https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)>Joe Armstrong</a> 撰写。我的翻译如下。</p><p>当我第一次接触<strong>OOP</strong>(Object Oriented Programming, 面向对象编程)概念的时候，就感到十分怀疑，但是又不知道为什么，就是感觉"不对&rdquo;。当OOP变得非常流行(下面会解释原因)，批判OOP就像&rdquo;<strong>在教堂诅咒</strong>&ldquo;一样会被排斥。OO逐渐成为了主流编程语言必须要有的特性。</p><p>随着Erlang变得流行，我们经常被问到"Erlang是面向对象的吗？"。<strong>真正的答案当然是"不支持&rdquo;</strong>，但是我们并不敢对外这么说，为此我们发明了一系列巧妙的方式来回答这个问题，给大家营造一种Erlang在某种程度上是OO，但又不真的是OO(如果仔细听我们说的，看小字印刷的内容就知道了)。</p><p>这个时候，我想到了 IBM 那时的老板在巴黎第七届IEEE Logic 编程会议时, 被问及IBM Prolog为什么添加了一系列面向对象的扩展，回答是：</p><blockquote><p>我们的客户希望使用面向对象的Prolog，所以我们就创造了面向对象的Prolog。</p></blockquote><p>我当时的想法是"这么简单粗暴的回答，没有任何良心上的不安，没有灵魂深处的拷问，也没有想过这是不是正确的事情 …&mldr;&rdquo;</p><h2 id=面向对象为什么糟糕>面向对象为什么糟糕</h2><p>对面向对象的主要反对理由可以回归到面向对象的基本理念，在这里我会简述其中一些基本理念以及我对它们的反对意见。</p><h3 id=反对1-数据结构和函数不应该捆绑在一起>反对1. 数据结构和函数不应该捆绑在一起</h3><p>对象将数据和函数绑定在了一个不可分割的单元。我认为<strong>这是一个根本性的错误</strong>，因为函数和数据属于完全不同的两个世界。为什么这么说呢？</p><ul><li>函数的作用是处理一些事情。它们有输入和输出。输入和输出是数据，数据可以被函数所改变。在大多数编程语言里，函数由一系列指令所构建：&ldquo;先干这个，之后再干那个……"。为了理解函数，你必须理解这些事情以何种顺序完成。(在支持延迟计算的函数式编程语言中，这个限制并不严格。)</li><li>而数据就静静的待在那里。它们什么都不做。它们本身是声明性的。&ldquo;理解"数据远比"理解"函数简单的多。</li></ul><p>为了便于理解，函数通常被当作"黑盒"处理，用来把输入转换成输出。如果我理解了输入和输出，那么我就理解了这个函数。<em>但这不意味着我可以写出这个函数。</em></p><p>通常可以认为函数是计算系统的一些"部件&rdquo;，它们的职责是从一种数据结构转换成另一种数据结构。</p><p><strong>函数和数据是完全不同的两类"动物&rdquo;，强行把它们锁在同一个"笼子"里，本身就是不正确的。</strong></p><h3 id=反对2-一切事物都必须是一个对象>反对2. 一切事物都必须是一个对象</h3><p>想想**&ldquo;时间&rdquo;**，在面向对象编程语言中，&ldquo;时间"必须是一个对象。(在Smalltalk中，甚至"3"都是一个对象)。但是在非面向对象的语言中，&ldquo;时间"只是某种数据类型的实例。例如，在Erlang中，存在各种各样的时间表示形式，通过使用类型声明可以清晰明确地进行指定，如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang>-deftype day()     <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>31</span>.
-deftype month()   <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>12</span>.
-deftype year()    <span style=color:#f92672>=</span> int().
-deftype hour()    <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>24</span>.
-deftype minute()  <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>60</span>.
-deftype second()  <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>60</span>.
-deftype abstime() <span style=color:#f92672>=</span> {abstime,year(),month(),day(),hour(),min(),sec()}.
-deftype hms()     <span style=color:#f92672>=</span> {hms,hour(),min(),sec()}.
<span style=color:#960050;background-color:#1e0010>…</span>
</code></pre></div><p>注意：上面的定义不属于任意特定的对象。它们是通用的，系统中的任意的函数（译者：这里的函数并不指代已有签名的那些函数，而是对函数的概指）都可以处理以上数据结构所表示的时间。</p><p>这里也没有任何关联的方法。</p><h3 id=反对3-在oop中到处都是数据类型定义>反对3. 在OOP中，到处都是数据类型定义</h3><p>在面向对象编程语言中，数据类型的定义属于对象的范畴。因此我没有办法在一个地方找到所有的数据类型定义。在Erlang或者C语言中，我可以把所有数据类型的定义放在同一个依赖文件或数据字典中。在面向对象里，我办不到，<strong>不得不把数据类型定义散播的到处都是</strong>。</p><p>举一个例子，假设我想定义一个通用数据类型。(通用数据类型是指在系统中各个地方都可能用到的数据类型)。</p><p>Lisp软件工程师应该早就知道，好的软件设计应该有少量的通用数据类型，和大量精简的函数处理这些类型，而不是拥有大量的数据类型和少量的函数。</p><p>通用数据类型有，链表、数组、哈希表，或者更高级的事物如时间、日期或者文件名等等。</p><p>在面向对象编程语言中，我必须选择某个基本对象，才能定义通用数据类型。所有其它希望使用这一数据类型的对象必须继承这个基本对象。假设我打算创建一些表示"时间"的实例，它应该属于哪个对象呢？</p><h3 id=反对4-对象存在私有状态>反对4. 对象存在私有状态</h3><p><strong>状态是罪恶之源</strong>。尤其是伴有副作用的函数更应当避免保存状态。</p><p>在编程语言中状态是不利因素，但在现实世界中状态确是个好东西。比如我对自己银行账户状态的变化就十分感兴趣，当我从银行存取钱时，我期望银行账户的状态被正确更新。</p><p>鉴于现实世界中存在状态，那么编程语言应当提供哪些基础设施来处理状态呢？</p><ul><li>面向对象编程语言说，&ldquo;向程序员隐藏状态&rdquo;。结果就是状态被隐藏起来，只有通过访问函数来获取。</li><li>面向过程的编程语言如C、Pascal说，状态变量的可见性应该由语言本身的作用域规则来控制。</li><li>纯粹的声明性语言说，就不该有状态。系统的全局状态传递给函数，函数处理完成之后再返回。一些机制如函数式编程中Monad和逻辑语言中的DCG，被用来向程序员隐藏状态，这样他们就可以假想自己在"状态无关紧要"的情况下编程，但事实是仍然可以获取系统的所有状态。</li></ul><p>面向对象编程语言所采用的"向程序员隐藏状态"的做法是最糟糕的。<strong>它们没有暴露状态，也没有试图寻找方法来最小化状态所带来的麻烦，只是把状态藏了起来。</strong></p><h2 id=面向对象为什么流行>面向对象为什么流行？</h2><ul><li>原因1：被认为更容易学习。</li><li>原因2：被认为更容易实现代码复用。</li><li>原因3：天花乱坠的广告宣传。</li><li>原因4：它创造了一套新的<strong>软件开发产业</strong>。</li></ul><p>我没有找到1和2的证据。3和4似乎是这项技术背后的直接驱动力。如果一种编程语言技术设计如此糟糕，以至于它需要创造一个新的产业来解决自己制造的问题，那么对于那些想通过这项技术赚钱的人来说，这的确是个好主意。</p><p>这就是面向对象编程流行的真正原因。</p><h2 id=参见-the-third-manifesto>参见 The Third Manifesto</h2><p>[本节英文原文由 R. A. O'Keefe 于2000年添加。]</p><p>由Date 和 Darwen 著作的<a href=https://en.wikipedia.org/wiki/The_Third_Manifesto>《The Third Manifesto》</a>是关于如何"合理"设计对象数据库。在附录中，他们对待SQL3 相当不温和，但比它应得的还算好。他们甚至对<a href=https://en.wikipedia.org/wiki/Object_Data_Management_Group>ODMG</a> 也做了批判。如果在花费了大量时间和财力的情况下，不能产出一个逻辑上一致的对象模型来匹配面向对象数据库系统，那么，也许OO就不会像看上去那么简单和好用了。</p><p>欢迎关注我的公众号: <em>沐风自语</em></p><p><img src=https://i.imgur.com/3EIrHxm.jpg alt=Imgur></p><p>原文链接：</p><p><a href=http://www.cs.otago.ac.nz/staffpriv/ok/Joe-Hates-OO.htm>http://www.cs.otago.ac.nz/staffpriv/ok/Joe-Hates-OO.htm</a></p></section></article><footer id=post-meta class=clearfix><a href=https://twitter.com/kaichaosun><img class=avatar src=https://kaichaosun.github.io/images/avatar.png><div><span class=dark>Kaichao Sun</span>
<span>Mark it down</span></div></a><section id=sharing><a class=twitter href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkaichaosun.github.io%2fpost%2fwhy_oo_sucks%2f - Why%20OO%20Sucks by @kaichaosun"><span class=icon-twitter>tweet</span></a>
<a class=facebook href=# onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;"><span class=icon-facebook-rect>Share</span></a></section></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"whisperd"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><ul id=post-list class="archive readmore"><iframe src=https://kaichao.substack.com/embed id=email-subscribe width=100% height=320 style="border:1px solid #eee;background:#fff;margin-top:60px" frameborder=0 scrolling=no></iframe><h3>Read more</h3><li><a href=/post/understand_decentralization/>如何理解去中心<aside class=dates>Feb 23 2022</aside></a></li><li><a href=/post/build_team/>Build in Public：创业团队的重要性<aside class=dates>Feb 11 2022</aside></a></li><li><a href=/post/substrate_history/>Substrate 技术演进<aside class=dates>Jan 22 2022</aside></a></li><li><a href=/post/metaverse/>元宇宙会不会把我们从一条人变成一条狗？<aside class=dates>Jan 21 2022</aside></a></li><li><a href=/post/substrate_network_libp2p/>Substrate 如何使用 libp2p 进行点对点通信<aside class=dates>Feb 8 2021</aside></a></li><li><a href=/post/substrate_read_source_code/>阅读Substrate源码的方法<aside class=dates>Jan 6 2021</aside></a></li><li><a href=/post/learn_substrate/>如何学习Substrate<aside class=dates>Jul 20 2020</aside></a></li><li><a href=/post/substrate_launch_public_testnet/>Substrate 部署公开测试网络<aside class=dates>Jul 17 2020</aside></a></li><li><a href=/post/how_to_blockchain/>如何学习区块链技术<aside class=dates>Apr 30 2020</aside></a></li><li><a href=/post/kusama_governance/>Kusama系列：如何进行链上治理<aside class=dates>Apr 16 2020</aside></a></li><li><a href=/post/substrate_node_template_guide/>Substrate代码导读：node-template<aside class=dates>Apr 2 2020</aside></a></li><li><a href=/post/trie/>理解Substrate数据存储的底层实现Merkle Patricia Trie<aside class=dates>Mar 17 2020</aside></a></li><li><a href=/post/substrate_transaction_weight_and_fees/>Substrate 区块链应用的交易费用设计<aside class=dates>Feb 21 2020</aside></a></li><li><a href=/post/substrate_storage_data_type/>Substrate存储数据类型概览<aside class=dates>Jan 19 2020</aside></a></li><li><a href=/post/coin_flip_test_and_ui/>抛硬币游戏(二)：编写测试和UI<aside class=dates>Oct 3 2019</aside></a></li><li><a href=/post/substrate_metadata/>Substrate Runtime Metadata<aside class=dates>Sep 7 2019</aside></a></li><li><a href=/post/substrate_coin_flip/>Substrate应用 - 抛硬币游戏(一)<aside class=dates>Aug 5 2019</aside></a></li><li><a href=/post/substrate_module_struct/>Substrate Module Struct<aside class=dates>Jul 30 2019</aside></a></li><li><a href=/post/substrate_blockchain_setup/>使用Substrate搭建你的第一条区块链<aside class=dates>May 28 2019</aside></a></li><li><a href=/post/solidity-basics/>理解Ethereum智能合约开发<aside class=dates>Apr 11 2019</aside></a></li></ul><footer id=footer><div id=social><a class=symbol href=https://github.com/kaichaosun><i class="fa fa-github"></i></a><a class=symbol href=https://twitter.com/kaichaosun><i class="fa fa-twitter"></i></a></div><p class=small>© Copyright 2022 Kaichao Sun</p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://kaichaosun.github.io/js/main.js></script><script src=https://kaichaosun.github.io/js/highlight.js></script><script src=https://kaichaosun.github.io/js/fix-toc.js></script><script>hljs.initHighlightingOnLoad();</script><script data-ad-client=ca-pub-2513693433628672 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-128168145-1','auto');ga('send','pageview');}</script></body></html>