<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kaichao Sun"><meta name=description content="kaichao's blog"><meta name=generator content="Hugo 0.62.2"><title>理解Substrate数据存储的底层实现Merkle Patricia Trie</title><link rel="shortcut icon" href=https://kaichaosun.github.io/images/favicon.ico><link rel=stylesheet href=https://kaichaosun.github.io/css/style.css><link rel=stylesheet href=https://kaichaosun.github.io/css/highlight.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css><link href=https://kaichaosun.github.io/index.xml rel=alternate type=application/rss+xml title=Whisperd><meta property="og:title" content="理解Substrate数据存储的底层实现Merkle Patricia Trie"><meta property="og:description" content="[TOC]
通过本文，你会了解到：
 区块链应用为什么使用Merkle Tree的数据结构； Substrate采用的Patricia Merkle Trie的特点和应用。  Merkle Tree介绍 Merkle Tree是一种数据结构，用来验证计算机之间存储和传输数据的一致性，如果不使用这一数据结构，一致性的验证需要消耗大量的存储和网络资源，如比对计算机之间的所有数据；使用Merkle Tree，只需要比对merkle root（根节点）就可以达到相同的效果。整个过程，简单的描述如下：
 将数据通过哈希之后放置在叶子节点之中； 将相邻两个数据的哈希值组合在一起，得出一个新的哈希值； 依次类推，直到只有一个节点也就是根节点； 在验证另外的计算机拥有和本机相同的数据时，只需验证其提供的根节点和自己的根节点一致即可。  Merke Tree使用了加密哈希算法来快速验证数据一致性，常用的加密哈希算法有SHA-256，SHA-3，Blake2等，它们可以做到，
 相同的输入有相同的输出； 对任意数据可以实现快速计算； 从哈希值无法推断出原信息； 不会碰撞（即不同输入对应相同输出）； 输入即使只有很小的改变，输出也会有极大不同。  在区块链应用Bitcoin网络中，存储的数据为转移Bitcoin的交易，如“Alice发送给Bob 5个比特币”，通过使用Merkle Tree，除了上面提到的验证各个节点之间的数据一致性，还可以用来快速验证一个交易是否属于某个区块。轻节点只需要下载很少的数据就可以验证交易的有效性，例如下图所示，用户要验证交易T(D)在某个区块之中，需要依赖的数据仅仅是HC, HAB, HEFGH, 和 merkle root即HABCDEFGH。
Merkle Patricia Trie原理 Trie Patria Trie也是一种树形的数据结构，也称为Prefix Tree，Radix Tree，或者简称为Trie，最早来源于英文单词 retrieve，可以发音为try，常用的使用场景包括：
 搜索引擎的自动补全功能； IP路由等。  Trie的特点是，某节点的key是从根节点到该节点的路径，即不同的key有相同前缀时，它们共享前缀所对应的路径。这种数据结构，可用于快速查找前缀相同的数据，内存开销较少。如以下数据及对应的trie表示为：
   key value     to 7   tea 3   ted 4   ten 12   A 15   i 11   in 5   inn 9    Substrate使用base-16，即每个节点最多有16个子节点："><meta property="og:type" content="article"><meta property="og:url" content="https://kaichaosun.github.io/post/trie/"><meta property="article:published_time" content="2020-03-17T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-17T00:00:00+00:00"><meta itemprop=name content="理解Substrate数据存储的底层实现Merkle Patricia Trie"><meta itemprop=description content="[TOC]
通过本文，你会了解到：
 区块链应用为什么使用Merkle Tree的数据结构； Substrate采用的Patricia Merkle Trie的特点和应用。  Merkle Tree介绍 Merkle Tree是一种数据结构，用来验证计算机之间存储和传输数据的一致性，如果不使用这一数据结构，一致性的验证需要消耗大量的存储和网络资源，如比对计算机之间的所有数据；使用Merkle Tree，只需要比对merkle root（根节点）就可以达到相同的效果。整个过程，简单的描述如下：
 将数据通过哈希之后放置在叶子节点之中； 将相邻两个数据的哈希值组合在一起，得出一个新的哈希值； 依次类推，直到只有一个节点也就是根节点； 在验证另外的计算机拥有和本机相同的数据时，只需验证其提供的根节点和自己的根节点一致即可。  Merke Tree使用了加密哈希算法来快速验证数据一致性，常用的加密哈希算法有SHA-256，SHA-3，Blake2等，它们可以做到，
 相同的输入有相同的输出； 对任意数据可以实现快速计算； 从哈希值无法推断出原信息； 不会碰撞（即不同输入对应相同输出）； 输入即使只有很小的改变，输出也会有极大不同。  在区块链应用Bitcoin网络中，存储的数据为转移Bitcoin的交易，如“Alice发送给Bob 5个比特币”，通过使用Merkle Tree，除了上面提到的验证各个节点之间的数据一致性，还可以用来快速验证一个交易是否属于某个区块。轻节点只需要下载很少的数据就可以验证交易的有效性，例如下图所示，用户要验证交易T(D)在某个区块之中，需要依赖的数据仅仅是HC, HAB, HEFGH, 和 merkle root即HABCDEFGH。
Merkle Patricia Trie原理 Trie Patria Trie也是一种树形的数据结构，也称为Prefix Tree，Radix Tree，或者简称为Trie，最早来源于英文单词 retrieve，可以发音为try，常用的使用场景包括：
 搜索引擎的自动补全功能； IP路由等。  Trie的特点是，某节点的key是从根节点到该节点的路径，即不同的key有相同前缀时，它们共享前缀所对应的路径。这种数据结构，可用于快速查找前缀相同的数据，内存开销较少。如以下数据及对应的trie表示为：
   key value     to 7   tea 3   ted 4   ten 12   A 15   i 11   in 5   inn 9    Substrate使用base-16，即每个节点最多有16个子节点："><meta itemprop=datePublished content="2020-03-17T00:00:00+00:00"><meta itemprop=dateModified content="2020-03-17T00:00:00+00:00"><meta itemprop=wordCount content="206"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="理解Substrate数据存储的底层实现Merkle Patricia Trie"><meta name=twitter:description content="[TOC]
通过本文，你会了解到：
 区块链应用为什么使用Merkle Tree的数据结构； Substrate采用的Patricia Merkle Trie的特点和应用。  Merkle Tree介绍 Merkle Tree是一种数据结构，用来验证计算机之间存储和传输数据的一致性，如果不使用这一数据结构，一致性的验证需要消耗大量的存储和网络资源，如比对计算机之间的所有数据；使用Merkle Tree，只需要比对merkle root（根节点）就可以达到相同的效果。整个过程，简单的描述如下：
 将数据通过哈希之后放置在叶子节点之中； 将相邻两个数据的哈希值组合在一起，得出一个新的哈希值； 依次类推，直到只有一个节点也就是根节点； 在验证另外的计算机拥有和本机相同的数据时，只需验证其提供的根节点和自己的根节点一致即可。  Merke Tree使用了加密哈希算法来快速验证数据一致性，常用的加密哈希算法有SHA-256，SHA-3，Blake2等，它们可以做到，
 相同的输入有相同的输出； 对任意数据可以实现快速计算； 从哈希值无法推断出原信息； 不会碰撞（即不同输入对应相同输出）； 输入即使只有很小的改变，输出也会有极大不同。  在区块链应用Bitcoin网络中，存储的数据为转移Bitcoin的交易，如“Alice发送给Bob 5个比特币”，通过使用Merkle Tree，除了上面提到的验证各个节点之间的数据一致性，还可以用来快速验证一个交易是否属于某个区块。轻节点只需要下载很少的数据就可以验证交易的有效性，例如下图所示，用户要验证交易T(D)在某个区块之中，需要依赖的数据仅仅是HC, HAB, HEFGH, 和 merkle root即HABCDEFGH。
Merkle Patricia Trie原理 Trie Patria Trie也是一种树形的数据结构，也称为Prefix Tree，Radix Tree，或者简称为Trie，最早来源于英文单词 retrieve，可以发音为try，常用的使用场景包括：
 搜索引擎的自动补全功能； IP路由等。  Trie的特点是，某节点的key是从根节点到该节点的路径，即不同的key有相同前缀时，它们共享前缀所对应的路径。这种数据结构，可用于快速查找前缀相同的数据，内存开销较少。如以下数据及对应的trie表示为：
   key value     to 7   tea 3   ted 4   ten 12   A 15   i 11   in 5   inn 9    Substrate使用base-16，即每个节点最多有16个子节点："><meta name=twitter:site content="@https://twitter.com/kaichaosun"></head><body><nav class=main-nav><a href=https://kaichaosun.github.io/><span class=arrow>←</span>Home</a>
<a href=/about/>About</a>
<a class=cta href=https://kaichaosun.github.io/index.xml>Subscribe</a></nav><section id=wrapper><article class=post><header><h1>理解Substrate数据存储的底层实现Merkle Patricia Trie</h1><h2 class=subtitle></h2><h2 class=headline>March 17, 2020<br></h2></header><aside><nav id=TableOfContents><ul><li><a href=#merkle-tree介绍>Merkle Tree介绍</a></li><li><a href=#merkle-patricia-trie原理>Merkle Patricia Trie原理</a><ul><li><a href=#trie>Trie</a></li><li><a href=#mpt>MPT</a></li><li><a href=#child-trie>Child Trie</a></li><li><a href=#区块裁剪>区块裁剪</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#引用>引用</a></li><li><a href=#更多>更多</a></li></ul></nav></aside><section id=post-body><p>[TOC]</p><p>通过本文，你会了解到：</p><ul><li>区块链应用为什么使用Merkle Tree的数据结构；</li><li>Substrate采用的Patricia Merkle Trie的特点和应用。</li></ul><h2 id=merkle-tree介绍>Merkle Tree介绍</h2><p>Merkle Tree是一种数据结构，用来验证计算机之间存储和传输数据的一致性，如果不使用这一数据结构，一致性的验证需要消耗大量的存储和网络资源，如比对计算机之间的所有数据；使用Merkle Tree，只需要比对merkle root（根节点）就可以达到相同的效果。整个过程，简单的描述如下：</p><ul><li>将数据通过哈希之后放置在叶子节点之中；</li><li>将相邻两个数据的哈希值组合在一起，得出一个新的哈希值；</li><li>依次类推，直到只有一个节点也就是根节点；</li><li>在验证另外的计算机拥有和本机相同的数据时，只需验证其提供的根节点和自己的根节点一致即可。</li></ul><p>Merke Tree使用了<a href=https://en.wikipedia.org/wiki/Cryptographic_hash_function>加密哈希算法</a>来快速验证数据一致性，常用的加密哈希算法有SHA-256，SHA-3，Blake2等，它们可以做到，</p><ul><li>相同的输入有相同的输出；</li><li>对任意数据可以实现快速计算；</li><li>从哈希值无法推断出原信息；</li><li>不会碰撞（即不同输入对应相同输出）；</li><li>输入即使只有很小的改变，输出也会有极大不同。</li></ul><p><img src=/static/trie/merkle_tree.png alt=merkle_tree></p><p>在区块链应用Bitcoin网络中，存储的数据为转移Bitcoin的交易，如“Alice发送给Bob 5个比特币”，通过使用Merkle Tree，除了上面提到的验证各个节点之间的数据一致性，还可以用来快速验证一个交易是否属于某个区块。轻节点只需要下载很少的数据就可以验证交易的有效性，例如下图所示，用户要验证交易T(D)在某个区块之中，需要依赖的数据仅仅是HC, HAB, HEFGH, 和 merkle root即HABCDEFGH。</p><p><img src=/static/trie/spv_bitcoin.jpg alt=spv></p><h2 id=merkle-patricia-trie原理>Merkle Patricia Trie原理</h2><h3 id=trie>Trie</h3><p><a href=https://en.wikipedia.org/wiki/Radix_tree>Patria Trie</a>也是一种树形的数据结构，也称为Prefix Tree，Radix Tree，或者简称为<code>Trie</code>，最早来源于英文单词 re<strong>trie</strong>ve，可以发音为<em>try</em>，常用的使用场景包括：</p><ul><li>搜索引擎的自动补全功能；</li><li>IP路由等。</li></ul><p><img src=/static/trie/trie_autocomplete.gif alt=trie_autocomplete></p><p>Trie的特点是，<strong>某节点的key是从根节点到该节点的路径</strong>，即不同的key有相同前缀时，它们共享前缀所对应的路径。这种数据结构，可用于快速查找前缀相同的数据，内存开销较少。如以下数据及对应的trie表示为：</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>to</td><td>7</td></tr><tr><td>tea</td><td>3</td></tr><tr><td>ted</td><td>4</td></tr><tr><td>ten</td><td>12</td></tr><tr><td>A</td><td>15</td></tr><tr><td>i</td><td>11</td></tr><tr><td>in</td><td>5</td></tr><tr><td>inn</td><td>9</td></tr></tbody></table><p><img src=/static/trie/trie_wiki.png alt=trie_wiki></p><p>Substrate使用base-16，即每个节点最多有16个子节点：</p><p><img src=/static/trie/base16_trie.png alt=base16_trie></p><h3 id=mpt>MPT</h3><p>Merkle Patricia Trie（下面简称MPT），在Trie的基础上，给每个节点计算了一个哈希值，在Substrate中，该值通过对节点内容进行Blake2运算取得，用来索引数据库和计算merkle root。也就是说，MPT用到了两种key的类型。</p><p><strong>一种是Trie路径所对应的key，由runtime模块的存储单元决定</strong>。使用Substrate开发的应用链，它所拥有的各个模块的存储单元会通过交易进行修改，成为链上状态（简称为state）。每个存储单元的状态都是通过键值对以trie节点的形式进行索引或者保存的，这里键值对的value是原始数据（如数值、布尔）的SCALE编码结果，并作为MPT节点内容的一部分进行保存；key是模块、存储单元等的哈希组合，且和存储数据类型紧密相关，如：</p><ul><li>单值类型（即Storage Value），它的key是<code>Twox128(module_prefix) ++ Twox128(storage_prefix)</code>；</li><li>简单映射类型（即map），可以表示一系列的键值数据，它的存储位置和map中的键相关，即<code>Twox128(module_prefix) + Twox128(storage_prefix) + hasher(encode(map_key))</code>；</li><li>链接映射类型（即linked_map），和map类似，key是<code>Twox128(module_prefix) + Twox128(storage_prefix) + hasher(encode(map_key))</code>；它的head存储在<code>Twox128(module) + Twox128("HeadOf" + storage_prefix)</code>；</li><li>双键映射类型（即double_map），key是<code>twox128(module_prefix) + twox128(storage_prefix) + hasher1(encode(map_key1)) + hasher2(encode(map_key2))</code>。</li></ul><p>计算key所用到 <a href=https://cyan4973.github.io/xxHash/>Twox128</a> 是一种非加密的哈希算法，计算速度非常快，但去除了一些严格的要求，如不会碰撞、很小的输入改变导致极大的输出改变等，从而无法保证安全性，适用于输入固定且数量有限的场景中。<code>module_prefix</code>通常是模块的实例名称；<code>storage_prefix</code>通常是存储单元的名称；原始的key通过SCALE编码器进行编码，再进行哈希运算，这里的哈希算法是可配置的，如果输入来源不可信如用户输入，则使用Blake2（也是默认的哈希算法），否则可以使用Twox。</p><p><strong>另一种是数据库存储和计算merkle root使用的key</strong>，可以通过对节点内容进行哈希运算得到，在键值数据库（即RocksDB，和LevelDB相比，<a href=https://github.com/facebook/rocksdb/wiki/Features-Not-in-LevelDB>RocksDB有更多的性能优化和特性</a>）中索引相应的trie节点。</p><p>Trie节点主要有三类，即叶子节点（Leaf）、有值分支节点（BranchWithValue）和无值分支节点（BranchNoValue）；有一个特例，当trie本身为空的时候存在唯一的空节点（Empty）。根据类型不同，trie节点存储内容有稍许不同，通常会包含header、trie路径的部分key、children节点以及value。下面举一个具体例子。</p><p><em><strong>Trie路径的key和value如下表所示</strong></em>：</p><p><img src=/static/trie/trie_kv_table_corp2.png alt=trie_kv_table></p><p><em><strong>将上表的数据展示为trie的结构之后得到下图</strong></em>：</p><p><img src=/static/trie/trie_visual.png alt=trie_visual></p><p>图上所示内容的说明如下：</p><ul><li>这里使用不同的header值来表示不同的节点类型，即01表示叶子节点，10表示无值的分支节点，11表示有值的分支节点。</li><li>为了提高存储和查找的效率，Substrate使用的MPT和基本的trie不同的是，并不是trie path key的每一位都对应一个节点，当key的连续位之间没有分叉时，节点可以直接使用该连续位。对于叶子节点，连续位可以是trie path key的最后几位；对于分支节点，连续位是从当前位开始到出现分叉位结束。</li><li>之前提到过，Substrate采用了base-16的trie结构，即一个分支节点最多可以有16个子节点。</li></ul><p><em><strong>接着，我们来添加每个节点的哈希</strong></em>：</p><p><img src=/static/trie/trie_visual_with_hash.png alt=trie_visual_with_hash></p><p>首先计算出叶子节点的哈希值，它们被上一级的分支节点所引用，用来在数据库中查找对应的节点；然后计算分支节点的哈希值，直至递归抵达根节点，这里用到的哈希算法是Blake2。</p><p><em>数据库的物理存储大致如下</em>：</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Hroot</td><td>encode(root_node)</td></tr><tr><td>H00</td><td>encode(node_00)</td></tr><tr><td>H01</td><td>encode(node_01)</td></tr><tr><td>H02</td><td>encode(node_02)</td></tr><tr><td>H03</td><td>encode(node_03)</td></tr><tr><td>H04</td><td>encode(node_04)</td></tr></tbody></table><p>数据库中存储的key是上面所计算的节点哈希；存储的value是节点内容的特定编码，对于节点中保存的值是对应的SCALE编码结果。</p><p>RocksDB提供了column的概念，用来存储互相隔离的数据。例如，HEADER column存储着所有的区块头；BODY column存储着所有的区块体，也就是所有的存储单元状态。</p><h3 id=child-trie>Child Trie</h3><p>Substrate还提供child trie这样的数据结构，它也是一个MPT。Substrate的应用链可以有很多child trie，每个child trie有唯一的标识进行索引，它们可以彼此隔离，提升存储和查询效率。State trie或者main trie的叶子节点可以是child trie的根哈希，来保存对应child trie的状态。Child trie的一个典型应用是Substrate的contracts功能模块，每一个智能合约对应着自己唯一的child trie。</p><h3 id=区块裁剪>区块裁剪</h3><p>区块的无限增长往往给去中心的节点造成较大的存储消耗，通常只有少数的节点需要提供过往历史数据，大部分节点在能够确保状态最终性之后，可以将不需要的区块数据删除，从而提升节点的性能。Substrate也内置了裁剪的功能，示意图如下：</p><p><img src=/static/trie/trie_visual_pruning.png alt=pruning></p><p>在区块13中，只有node-4的值从04变为40，其哈希也跟着改变，而其它节点的数据并没有变化，所以新的区块根节点可以复用原有节点，仅仅更新发生变化的节点。假设区块13已经具有最终性，那么区块12中的node-4就可以删除掉。Substrate默认的区块生成算法是BABE或者Aura，而最终性是通过GRANDPA来决定的，在网络稳定的情况下，仅保留一定数量的最新区块是可行的。</p><h2 id=总结>总结</h2><p>本文介绍了区块链应用必不可少Merkle Tree，以及Substrate采用的Patricia Merkle Trie的不同之处。需要说明的是，Substrate还提供了强大的cache功能，来提升读写效率。</p><h2 id=引用>引用</h2><p><a href="https://www.youtube.com/watch?v=9S8rmW8LD5o&t=3s">Deep Dive - Substrate Storage</a></p><p><a href=https://github.com/paritytech/substrate/pull/3201>Allow updating configuration of changes tries</a></p><p><a href=https://www.ideserve.co.in/learn/trie-insert-and-search>Trie Data Structure | Insert and search</a></p><p><a href=https://en.wikipedia.org/wiki/Trie>Wiki Trie</a></p><p><a href=https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014>Trying to Understand Tries</a></p><p><a href=https://leetcode.com/articles/implement-trie-prefix-tree/>Implement Trie (Prefix Tree)</a></p><p><a href=https://www.slideshare.net/aniruddha.chakrabarti/level-db-quick-cheat-sheet>Level DB - Quick Cheat Sheet</a></p><p><a href=https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/>Understanding the ethereum trie</a></p><p><a href=https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed>Diving into Ethereum’s world state</a></p><p><a href=https://www.mycryptopedia.com/merkle-tree-merkle-root-explained/>Merkle Tree & Merkle Root Explained</a></p><h2 id=更多>更多</h2><p>Substrate官方文档：<a href=https://substrate.dev/>https://substrate.dev/</a></p><p>Parity介绍：<a href=https://www.parity.io/>https://www.parity.io/</a></p><p>Substrate源码：<a href=https://github.com/paritytech/substrate>https://github.com/paritytech/substrate</a></p><p>Polkadot源码：<a href=https://github.com/paritytech/polkadot>https://github.com/paritytech/polkadot</a></p></section></article><footer id=post-meta class=clearfix><a href=https://twitter.com/SunWillsuna><img class=avatar src=https://kaichaosun.github.io/images/avatar.png><div><span class=dark>Kaichao Sun</span>
<span>Mark it down</span></div></a><section id=sharing><a class=twitter href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkaichaosun.github.io%2fpost%2ftrie%2f - %e7%90%86%e8%a7%a3Substrate%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0Merkle%20Patricia%20Trie by @SunWillsuna"><span class=icon-twitter>tweet</span></a>
<a class=facebook href=# onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;"><span class=icon-facebook-rect>Share</span></a></section></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"whisperd"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><ul id=post-list class="archive readmore"><h3>Read more</h3><li><a href=/post/substrate_node_template_guide/>Substrate代码导读：node-template<aside class=dates>Apr 2 2020</aside></a></li><li><a href=/post/substrate_transaction_weight_and_fees/>Substrate 区块链应用的交易费用设计<aside class=dates>Feb 21 2020</aside></a></li><li><a href=/post/substrate_storage_data_type/>Substrate存储数据类型概览<aside class=dates>Jan 19 2020</aside></a></li><li><a href=/post/coin_flip_test_and_ui/>抛硬币游戏(二)：编写测试和UI<aside class=dates>Oct 3 2019</aside></a></li><li><a href=/post/substrate_coin_flip/>Substrate应用 - 抛硬币游戏(一)<aside class=dates>Aug 5 2019</aside></a></li><li><a href=/post/substrate_blockchain_setup/>使用Substrate搭建你的第一条区块链<aside class=dates>May 28 2019</aside></a></li><li><a href=/post/why_oo_sucks/>Why OO Sucks<aside class=dates>Apr 25 2019</aside></a></li><li><a href=/post/solidity-basics/>理解Ethereum智能合约开发<aside class=dates>Apr 11 2019</aside></a></li><li><a href=/post/shell-cheatsheet/>Cheatsheet for Shell Programming<aside class=dates>Mar 30 2019</aside></a></li><li><a href=/post/master_linux_os/>The Tutorial of Manjaro Linux Usage<aside class=dates>Mar 3 2019</aside></a></li></ul><footer id=footer><div id=social><a class=symbol href=https://github.com/kaichaosun><i class="fa fa-github"></i></a><a class=symbol href=https://twitter.com/kaichaosun><i class="fa fa-twitter"></i></a></div><p class=small>© Copyright 2020 Kaichao Sun</p></footer></section><script src=//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js></script><script src=https://kaichaosun.github.io/js/main.js></script><script src=https://kaichaosun.github.io/js/highlight.js></script><script src=https://kaichaosun.github.io/js/fix-toc.js></script><script>hljs.initHighlightingOnLoad();</script><script data-ad-client=ca-pub-2513693433628672 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-128168145-1','auto');ga('send','pageview');}</script></body></html>